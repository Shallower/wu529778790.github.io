---
title: 高级篇
date: 2022-04-21 11:09:01
permalink: /pages/4c5f2b615e68a/
categories:
  - 面试突击
tags:
  -
---

【腾讯文档】3、第三部分：高级篇(91 题).

<!-- more -->

## JavaScript 进阶

### 内置类型

- 基本类型和对象类型
- 基本类型有七种：null,undefined,boolean,number,string,symbol,bigInt
- 其中 JS 的数字类型是浮点类型的，没有整型。并且浮点类型基于 IEEE 754 标准实现，在使⽤中会遇到某些 Bug。 NaN 也属于 number 类型，并且 NaN 不等于⾃身。
- 对于基本类型来说，如果使⽤字⾯量的⽅式，那么这个变量只是个字⾯量，只有在必要的时候才会转换为对应的类型。

```js
let a = 111; // 这只是字⾯量，不是 number 类型
a.toString(); // 使⽤时候才会转换为对象类型
```

### typeof

> typeof 对于基本类型，除了 null 都可以显示正确的类型

```js
typeof 1; // 'number'
typeof "1"; // 'string'
typeof undefined; // 'undefined'
typeof true; // 'boolean'
typeof Symbol(); // 'symbol'
typeof b; // b 没有声明，但是还会显示 undefined
```

> typeof 对于对象，除了函数都会显示 object

```js
typeof []; // 'object'
typeof {}; // 'object'
typeof console.log; // 'function'
```

> 对于 null 来说，虽然它是基本类型，但是会显示 object ，这是⼀个存在很久了的 Bug

> PS：为什么会出现这种情况呢？因为在 JS 的最初版本中，使⽤的是 32 位系统，为了性能考虑使⽤低位存储了变量的类型信息， 000 开头代表是对象，然⽽ null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是⼀直流传下来。

如果我们想获得⼀个变量的正确类型，可以通过
`Object.prototype.toString.call(xx)` 。这样我们就可以获得类似 [object Type]
的字符串

```js
typeof undefined; // 'undefined'
typeof true; // 'boolean'
typeof Symbol(); // 'symbol'
typeof b; // b 没有声明，但是还会显示 undefined
typeof []; // 'object'
typeof {}; // 'object'
typeof console.log; // 'function'
typeof null; // 'object'
let a;
// 我们也可以这样判断 undefined
a === undefined;
// 但是 undefined 不是保留字，能够在低版本浏览器被赋值
let undefined = 1;
// 这样判断就会出错
// 所以可以⽤下⾯的⽅式来判断，并且代码量更少
// 因为 void 后⾯随便跟上⼀个组成表达式
// 返回就是 undefined
a === void 0;
```

数据类型看这个：<https://blog.shenzjd.com/pages/15beed3c2f8d4/>

### 类型转换

#### 转 Boolean

> 在条件判断时，除了 undefined ， null ， false ， NaN ， '' ，0 ， -0 ，其他所有值都转为 true ，包括所有对象

#### 对象转基本类型

> 对象在转换基本类型时，⾸先会调⽤ valueOf 然后调⽤ toString 。并且这两个⽅法你是可以重写的

#### 四则运算符

> 只有当加法运算时，其中⼀⽅是字符串类型，就会把另⼀个也转为字符串类型。其他运算只要其中⼀⽅是数字，那么另⼀⽅就转为数字。并且加法运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串

```js
1 + "1"; // '11'
2 * "2"; // 4
[1, 2] + [2, 1]; // '1,22,1'
// [1, 2].toString() -> '1,2'
// [2, 1].toString() -> '2,1'
// '1,2' + '2,1' = '1,22,1'
```

> 对于加号需要注意这个表达式 'a' + + 'b'

```js
"a" + +"b"; // -> "aNaN"
// 因为 + 'b' -> NaN
// 你也许在⼀些代码中看到过 + '1' -> 1
```

#### == 操作符

> 这⾥来解析⼀道题⽬ [] == ![] // -> true ，下⾯是这个表达式为何为 true 的步骤

```js
// [] 转成 true，然后取反变成 false
[] == false
// 根据第 8 条得出
[] == ToNumber(false)
[] == 0
// 根据第 10 条得出
ToPrimitive([]) == 0
// [].toString() -> ''
'' == 0
// 根据第 6 条得出
0 == 0 // -> true
```

#### ⽐较运算符

- 如果是对象，就通过 toPrimitive 转换对象
- 如果是字符串，就通过 unicode 字符索引来⽐较

隐士类型转换可以看这个：<https://blog.shenzjd.com/pages/52123c6f578c7/>

### 原型

![29e47abe1bb04e06a28c08dcd620d77b](https://cdn.jsdelivr.net/gh/wu529778790/image/blog/29e47abe1bb04e06a28c08dcd620d77b.png)

- 每个函数都有 prototype 属性，除了 Function.prototype.bind() ，该属性指向原型
- 每个对象都有 **proto** 属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 [[prototype]] ，但是 [[prototype]] 是内部属性，我们并不能访问到，所以使⽤ _proto_ 来访问
- 对象可以通过 **proto** 来寻找不属于该对象的属性， **proto** 将对象连接起来组成了原型链

原型看这个：<https://blog.shenzjd.com/pages/680e335c611f2/>

### new

- 新⽣成了⼀个对象
- 链接到原型
- 绑定 this
- 返回新对象

> 在调⽤ new 的过程中会发⽣以上四件事情，我们也可以试着来⾃⼰实现⼀个 new

```js
function create() {
  // 创建⼀个空的对象
  let obj = new Object();
  // 获得构造函数
  let Con = [].shift.call(arguments);
  // 链接到原型
  obj.__proto__ = Con.prototype;
  // 绑定 this，执⾏构造函数
  let result = Con.apply(obj, arguments);
  // 确保 new 出来的是个对象
  return typeof result === "object" ? result : obj;
}
```

new 操作符可以看这个：<https://blog.shenzjd.com/pages/71d970640a8d9/>

### instanceof

> instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype

```js
function instanceof(left, right) {
 // 获得类型的原型
 let prototype = right.prototype
 // 获得对象的原型
 left = left.__proto__
 // 判断对象的类型是否等于类型的原型
 while (true) {
 if (left === null)
 return false
 if (prototype === left)
 return true
 left = left.__proto__
 }
}
```

手写 instanceof：<https://blog.shenzjd.com/pages/15beed3c2f8d4/#%E5%AE%9E%E7%8E%B0-instanceof-%E5%8A%9F%E8%83%BD>

### this

```js
function foo() {
  console.log(this.a);
}
var a = 1;
foo();
var obj = {
  a: 2,
  foo: foo,
};
obj.foo();
// 以上两者情况 `this` 只依赖于调⽤函数前的对象，优先级是第⼆个情况⼤于第⼀个情况
// 以下情况是优先级最⾼的，`this` 只会绑定在 `c` 上，不会被任何⽅式修改 `this` 指向
var c = new foo();
c.a = 3;
console.log(c.a);
// 还有种就是利⽤ call，apply，bind 改变 this，这个优先级仅次于 new
```

> 看看箭头函数中的 this

```js
function a() {
  return () => {
    return () => {
      console.log(this);
    };
  };
}
console.log(a()()());
```

> 箭头函数其实是没有 this 的，这个函数中的 this 只取决于他外⾯的第⼀个不是箭头函数的函数的 this 。在这个例⼦中，因为调⽤ a 符合前⾯代码中的第⼀个情况，所以 this 是 window 。并且 this ⼀旦绑定了上下⽂，就不会被任何代码改变

### 执行上下文

> 当执⾏ JS 代码时，会产⽣三种执⾏上下⽂

- 全局执⾏上下⽂
- 函数执⾏上下⽂
- eval 执⾏上下⽂

> 每个执⾏上下⽂中都有三个重要的属性

- 变量对象（ VO ），包含变量、函数声明和函数的形参，该属性只能在全局上下⽂中访问
- 作⽤域链（ JS 采⽤词法作⽤域，也就是说变量的作⽤域是在定义时就决定了）
- this

```js
var a = 10;
function foo(i) {
  var b = 20;
}
foo();
```

> 对于上述代码，执⾏栈中有两个上下⽂：全局上下⽂和函数 foo 上下⽂。

```js
stack = [globalContext, fooContext];
```

> 对于全局上下⽂来说， VO ⼤概是这样的

```js
globalContext.VO === globe
globalContext.VO = {
  a: undefined,
  foo: <Function>,
}
```

> 对于函数 foo 来说， VO 不能访问，只能访问到活动对象（ AO ）

```js
// arguments 是函数独有的对象(箭头函数没有)
// 该对象是⼀个伪数组，有 `length` 属性且可以通过下标访问元素
// 该对象中的 `callee` 属性代表函数本身
// `caller` 属性代表函数的调⽤者
fooContext.VO === foo.AO
fooContext.AO {
 i: undefined,
 b: undefined,
 arguments: <>
}
```

> 对于作⽤域链，可以把它理解成包含⾃身变量对象和上级变量对象的列表，通过 [[Scope]] 属性查找上级变量

```js
fooContext.[[Scope]] = [
 globalContext.VO
]
fooContext.Scope = fooContext.[[Scope]] + fooContext.VO
fooContext.Scope = [
 fooContext.VO,
 globalContext.VO
]
```

> 接下来让我们看⼀个⽼⽣常谈的例⼦， var

```js
b(); // call b
console.log(a); // undefined
var a = "Hello world";
function b() {
  console.log("call b");
}
```

> 想必以上的输出⼤家肯定都已经明⽩了，这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于⼤家理解。但是更准确的解释应该是：在⽣成执⾏上下⽂时，会有两个阶段。第⼀个阶段是创建的阶段（具体步骤是创建 VO ）， JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存⼊内存中，变量只声明并且赋值为 undefined ，所以在第⼆个阶段，也就是代码执⾏阶段，我们可以直接提前使⽤

- 在提升的过程中，相同的函数会覆盖上⼀个函数，并且函数优先于变量提升

```js
b(); // call b second
function b() {
  console.log("call b fist");
}
function b() {
  console.log("call b second");
}
var b = "Hello world";
```

> var 会产⽣很多错误，所以在 ES6 中引⼊了 let 。 let 不能在声明前使⽤，但是这并不是常说的 let 不会提升， let 提升了声明但没有赋值，因为临时死区导致了并不能在声明前使⽤

- 对于⾮匿名的⽴即执⾏函数需要注意以下⼀点

```js
var foo = 1(
  (function foo() {
    foo = 10;
    console.log(foo);
  })()
); // -> ƒ foo() { foo = 10 ; console.log(foo) }
```

> 因为当 JS 解释器在遇到⾮匿名的⽴即执⾏函数时，会创建⼀个辅助的特定对象，然后将函数名称作为这个对象的属性，因此函数内部才可以访问到 foo ，但是这个值⼜是只读的，所以对它的赋值并不⽣效，所以打印的结果还是这个函数，并且外部的值也没有发⽣更改。

```js
specialObject = {};
Scope = specialObject + Scope;
foo = new FunctionExpression;
foo.[[Scope]] = Scope;
specialObject.foo = foo; // {DontDelete}, {ReadOnly}
delete Scope[0]; // remove specialObject from the front of scope chain
```

### 闭包

> 闭包的定义很简单：函数 A 返回了⼀个函数 B，并且函数 B 中使⽤了函数 A
> 的变量，函数 B 就被称为闭包

```js
function A() {
  let a = 1;
  function B() {
    console.log(a);
  }
  return B;
}
```

闭包定义建议看:<https://blog.shenzjd.com/pages/84526eb582265/>

> 你是否会疑惑，为什么函数 A 已经弹出调⽤栈了，为什么函数 B 还能引⽤到函数 A 中的变量。因为函数 A 中的变量这时候是存储在堆上的。现在的 JS 引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上

经典⾯试题，循环中使⽤闭包解决 var 定义函数的问题

```js
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```

- ⾸先因为 setTimeout 是个异步函数，所有会先把循环全部执⾏完毕，这时候 i 就是 6 了，所以会输出⼀堆 6
- 解决办法两种，第⼀种使⽤闭包

```js
for (var i = 1; i <= 5; i++) {
  (function (j) {
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })(i);
}
```

- 第⼆种就是使⽤ setTimeout 的第三个参数

```js
for (var i = 1; i <= 5; i++) {
  setTimeout(
    function timer(j) {
      console.log(j);
    },
    i * 1000,
    i
  );
}
```

- 第三种就是使⽤ let 定义 i 了

```js
for (let i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```

因为对于 let 来说，他会创建⼀个块级作⽤域，相当于

```js
{
  // 形成块级作⽤域
  let i = 0;
  {
    let ii = isetTimeout(function timer() {
      console.log(i);
    }, i * 1000);
  }
  i++;
  {
    let ii = i;
  }
  i++;
  {
    let ii = i;
  }
  ...
}
```

### 深浅拷贝

```js
letet a a = {
 age : 1
}
let b = a
a.age = 2
console.log(b.age) // 2
```

- 从上述例⼦中我们可以发现，如果给⼀个变量赋值⼀个对象，那么两者的值会是同⼀个引⽤，其中⼀⽅改变，另⼀⽅也会相应改变。
- 通常在开发中我们不希望出现这样的问题，我们可以使⽤浅拷⻉来解决这个问题

#### 浅拷贝

> ⾸先可以通过 Object.assign 来解决这个问题

```js
let a = {
  age: 1,
};
let b = Object.assign({}, a);
a.age = 2;
console.log(b.age); // 1
```

> 当然我们也可以通过展开运算符 （…） 来解决

```js
let a = {
  age: 1,
};
let b = { ...a };
a.age = 2;
console.log(b.age); // 1
```

> 通常浅拷⻉就能解决⼤部分问题了，但是当我们遇到如下情况就需要使⽤到深拷⻉了

```js
let a = {
  age: 1,
  jobs: {
    first: "FE",
  },
};
let b = { ...a };
a.jobs.first = "native";
console.log(b.jobs.first); // native
```

> 浅拷⻉只解决了第⼀层的问题，如果接下去的值中还有对象的话，那么就⼜回到刚开始的话题了，两者享有相同的引⽤。要解决这个问题，我们需要引⼊深拷

#### 深拷贝

> 这个问题通常可以通过 JSON.parse(JSON.stringify(object)) 来解决

```js
let a = {
  age: 1,
  jobs: {
    first: "FE",
  },
};
let b = JSON.parse(JSON.stringify(a));
a.jobs.first = "native";
console.log(b.jobs.first); // FE
```

> 但是该⽅法也是有局限性的：

- 会忽略 undefined
- 不能序列化函数
- 不能解决循环引⽤的对象

```js
let obj = {
  a: 1,
  b: {
    c: 2,
    d: 3,
  },
};
obj.c = obj.b;
obj.e = obj.a;
obj.b.c = obj.c;
obj.b.d = obj.b;
obj.b.e = obj.b.c;
let newObj = JSON.parse(JSON.stringify(obj));
console.log(newObj);
```

> 如果你有这么⼀个循环引⽤对象，你会发现你不能通过该⽅法深拷⻉

在遇到函数或者 undefined 的时候，该对象也不能正常的序列化

```js
let a = {
  age: undefined,
  jobs: function () {},
  name: "poetries",
};
let b = JSON.parse(JSON.stringify(a));
console.log(b); // {name: "poetries"}
```

- 你会发现在上述情况中，该⽅法会忽略掉函数和`undefined。
- 但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决⼤部分问题，并且该函数是内置函数中处理深拷⻉性能最快的。当然如果你的数据中含有以上三种情况下，可以使⽤ lodash 的深拷⻉函数

### 模块化

> 在有 Babel 的情况下，我们可以直接使⽤ ES6 的模块化

```js
// file a.js
export function a() {}
export function b() {}
// file b.js
export default function () {}
import { a, b } from "./a.js";
import XXX from "./b.js";
```

#### commonjs

> CommonJs 是 Node 独有的规范，浏览器中使⽤就需要⽤到 Browserify 解析了。

```js
// a.js
module.exports = {
  a: 1,
};
// or
exports.a = 1;
// b.js
var module = require("./a.js");
module.a; // -> log 1
```

> 在上述代码中， module.exports 和 exports 很容易混淆，让我们来看看⼤致内部实现

```js
var module = require("./a.js");
module.a;
// 这⾥其实就是包装了⼀层⽴即执⾏函数，这样就不会污染全局变量了，
// 重要的是 module 这⾥，module 是 Node 独有的⼀个变量
module.exports = {
  a: 1,
};
// 基本实现
var module = {
  exports: {}, // exports 就是个空对象
};
// 这个是为什么 exports 和 module.exports ⽤法相似的原因
var exports = module.exports;
var load = function (module) {
  // 导出的东⻄
  var a = 1;
  module.exports = a;
  return module.exports;
};
```

> 再来说说 module.exports 和 exports ，⽤法其实是相似的，但是不能对 exports 直接赋值，不会有任何效果

> 对于 CommonJS 和 ES6 中的模块化的两者区别是：

- 前者⽀持动态导⼊，也就是 require(${path}/xx.js) ，后者⽬前不⽀持，但是已有提案,前者是同步导⼊，因为⽤于服务端，⽂件都在本地，同步导⼊即使卡住主线程影响也不⼤
- ⽽后者是异步导⼊，因为⽤于浏览器，需要下载⽂件，如果也采⽤同步导⼊会对渲染有很⼤影响
- 前者在导出时都是值拷⻉，就算导出的值变了，导⼊的值也不会改变，所以如果想更新值，必须重新导⼊⼀次
- 但是后者采⽤实时绑定的⽅式，导⼊导出的值都指向同⼀个内存地址，所以导⼊值会跟随导出值变化
- 后者会编译成 require/exports 来执⾏的

#### AMD

> AMD 是由 RequireJS 提出的

```js
// AMD
define(["./a", "./b"], function (a, b) {
  a.do();
  b.do();
});
define(function (require, exports, module) {
  var a = require("./a");
  a.doSomething();
  var b = require("./b");
  b.doSomething();
});
```

### 防抖

> 你是否在⽇常开发中遇到⼀个问题，在滚动事件中需要做个复杂计算或者实现⼀个按钮的防⼆次点击操作。

- 这些需求都可以通过函数防抖动来实现。尤其是第⼀个需求，如果在频繁的事件回调中做复杂计算，很有可能导致⻚⾯卡顿，不如将多次计算合并为⼀次计算，只在⼀个精确点做操作
- PS：防抖和节流的作⽤都是防⽌函数多次调⽤。区别在于，假设⼀个⽤户⼀直触发这个函数，且每次触发函数的间隔⼩于 wait ，防抖的情况下只会调⽤⼀次，⽽节流的 情况会每隔⼀定时间（参数 wait ）调⽤函数

```js
// 这个是⽤来获取当前时间戳的
function now() {
  return +new Date();
}
/**
 * 防抖函数，返回函数连续调⽤时，空闲时间必须⼤于或等于 wait，func 才会执⾏
 *
 * @param {function} func 回调函数
 * @param {number} wait 表示时间窗⼝的间隔
 * @param {boolean} immediate 设置为ture时，是否⽴即调⽤函数
 * @return {function} 返回客户调⽤函数
 */
function debounce(func, wait = 50, immediate = true) {
  let timer, context, args;
  // 延迟执⾏函数
  const later = () =>
    setTimeout(() => {
      // 延迟函数执⾏完毕，清空缓存的定时器序号
      timer = null;
      // 延迟执⾏的情况下，函数会在延迟函数中执⾏
      // 使⽤到之前缓存的参数和上下⽂
      if (!immediate) {
        func.apply(context, args);
        context = args = null;
      }
    }, wait);
  // 这⾥返回的函数是每次实际调⽤的函数
  return function (...params) {
    // 如果没有创建延迟执⾏函数（later），就创建⼀个
    if (!timer) {
      timer = later();
      // 如果是⽴即执⾏，调⽤函数
      // 否则缓存参数和调⽤上下⽂
      if (immediate) {
        func.apply(this, params);
      } else {
        context = this;
        args = params;
      }
      // 如果已有延迟执⾏函数（later），调⽤的时候清除原来的并重新设定⼀个
      // 这样做延迟函数会重新计时
    } else {
      clearTimeout(timer);
      timer = later();
    }
  };
}
```

- 对于按钮防点击来说的实现：如果函数是⽴即执⾏的，就⽴即调⽤，如果函数是延迟执⾏的，就缓存上下⽂和参数，放到延迟函数中去执⾏。⼀旦我开始⼀个定时器，只要我定时器还在，你每次点击我都重新计时。⼀旦你点累了，定时器时间到，定时器重置为 null ，就可以再次点击了
- 对于延时执⾏函数来说的实现：清除定时器 ID ，如果是延迟调⽤就调⽤函数

### 节流

> 防抖动和节流本质是不⼀样的。防抖动是将多次执⾏变为最后⼀次执⾏，节流是将多次执⾏变成每隔⼀段时间执⾏

```js
/**
 * underscore 节流函数，返回函数连续调⽤时，func 执⾏频率限定为 次 / wait*
 * @param {function} func 回调函数
 * @param {number} wait 表示时间窗⼝的间隔
 * @param {object} options 如果想忽略开始函数的的调⽤，传⼊{leading: false
 * 如果想忽略结尾函数的调⽤，传⼊{trailing: false
 * 两者不能共存，否则函数不能执⾏
 * @return {function} 返回客户调⽤函数
 */
_.throttle = function (func, wait, options) {
  var context, args, result;
  var timeout = null;
  // 之前的时间戳
  var previous = 0;
  // 如果 options 没传则设为空对象
  if (!options) options = {};
  // 定时器回调函数
  var later = function () {
    // 如果设置了 leading，就将 previous 设为 0
    // ⽤于下⾯函数的第⼀个 if 判断
    previous = options.leading === false ? 0 : _.now();
    // 置空⼀是为了防⽌内存泄漏，⼆是为了下⾯的定时器判断
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null;
  };
  return function () {
    // 获得当前时间戳
    var now = _.now();
    // ⾸次进⼊前者肯定为 true
    // 如果需要第⼀次不执⾏函数
    // 就将上次时间戳设为当前的
    // 这样在接下来计算 remaining 的值时会⼤于0
    if (!previous && options.leading === false) previous = now;
    // 计算剩余时间
    var remaining = wait - (now - previous);
    context = this;
    args = arguments;
    // 如果当前调⽤已经⼤于上次调⽤时间 + wait
    // 或者⽤户⼿动调了时间
    // 如果设置了 trailing，只会进⼊这个条件
    // 如果没有设置 leading，那么第⼀次会进⼊这个条件
    // 还有⼀点，你可能会觉得开启了定时器那么应该不会进⼊这个 if 条件了
    // 其实还是会进⼊的，因为定时器的延时
    // 并不是准确的时间，很可能你设置了2秒
    // 但是他需要2.2秒才触发，这时候就会进⼊这个条件
    if (remaining <= 0 || remaining > wait) {
      // 如果存在定时器就清理掉否则会调⽤⼆次回调
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout && options.trailing !== false) {
      // 判断是否设置了定时器和 trailing
      // 没有的话就开启⼀个定时器
      // 并且不能不能同时设置 leading 和 trailing
      timeout = setTimeout(later, remaining);
    }
    return result;
  };
};
```

防抖节流建议看： <https://blog.shenzjd.com/pages/3c209d1a362c4/#%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0>

### 继承

> 在 ES5 中，我们可以使⽤如下⽅式解决继承的问题

```js
function Super() {}
Super.prototype.getNumber = function () {
  return 1;
};
function Sub() {}
let s = new Sub();
Sub.prototype = Object.create(Super.prototype, {
  constructor: {
    value: Sub,
    enumerable: false,
    writable: true,
    configurable: true,
  },
});
```

- 以上继承实现思路就是将⼦类的原型设置为⽗类的原型
- 在 ES6 中，我们可以通过 class 语法轻松解决这个问题

```js
class MyDate extends Date {
  test() {
    return this.getTime();
  }
}
let myDate = new MyDate();
myDate.test();
```

- 但是 ES6 不是所有浏览器都兼容，所以我们需要使⽤ Babel 来编译这段代码。
- 如果你使⽤编译过得代码调⽤ myDate.test() 你会惊奇地发现出现了报错

> 因为在 JS 底层有限制，如果不是由 Date 构造出来的实例的话，是不能调⽤ Date ⾥的函数的。所以这也侧⾯的说明了： ES6 中的 class 继承与 ES5 中的⼀般继承写法是不同的

- 既然底层限制了实例必须由 Date 构造出来，那么我们可以改变下思路实现继承

```js
function MyData() {}
MyData.prototype.test = function () {
  return this.getTime();
};
let d = new Date();
Object.setPrototypeOf(d, MyData.prototype);
Object.setPrototypeOf(MyData.prototype, Date.prototype);
```

- 以上继承实现思路：先创建⽗类实例 => 改变实例原先的 \_\_proto\_\_ 转⽽连接到⼦类的 prototype => ⼦类的 prototype 的 \_\_proto\_\_ 改为⽗类的 prototype
- 通过以上⽅法实现的继承就可以完美解决 JS 底层的这个限制

继承建议看这个： <https://blog.shenzjd.com/pages/b58b52fcbc575/>

### call, apply, bind

- call 和 apply 都是为了解决改变 this 的指向。作⽤都是相同的，只是传参的⽅式不同
- 除了第⼀个参数外， call 可以接收⼀个参数列表， apply 只接受⼀个参数数组

```js
let a = {
  value: 1,
};
function getValue(name, age) {
  console.log(name);
  console.log(age);
  console.log(this.value);
}
getValue.call(a, "shenzjd.com", "24");
getValue.apply(a, ["shenzjd.com", "24"]);
```

call,apply,bind 建议看：<https://blog.shenzjd.com/pages/7a05690c28407/>

### Promise

- 可以把 Promise 看成⼀个状态机。初始是 pending 状态，可以通过函数 resolve 和 reject ，将状态转变为 resolved 或者 rejected 状态，状态⼀旦改变就不能再次变化。
- then 函数会返回⼀个 Promise 实例，并且该返回值是⼀个新的实例⽽不是之前的实例。因为 Promise 规范规定除了 pending 状态，其他状态是不可以改变的，如果返回的是⼀个相同实例的话，多个 then 调⽤就失去意义了

```js
// 三种状态
const PENDING = "pending";
const RESOLVED = "resolved";
const REJECTED = "rejected";
// promise 接收⼀个函数参数，该函数会⽴即执⾏
function MyPromise(fn) {
  let _this = this;
  _this.currentState = PENDING;
  _this.value = undefined;
  // ⽤于保存 then 中的回调，只有当 promise
  // 状态为 pending 时才会缓存，并且每个实例⾄多缓存⼀个
  _this.resolvedCallbacks = [];
  _this.rejectedCallbacks = [];
  _this.resolve = function (value) {
    if (value instanceof MyPromise) {
      // 如果 value 是个 Promise，递归执⾏
      return value.then(_this.resolve, _this.reject);
    }
    setTimeout(() => {
      // 异步执⾏，保证执⾏顺序
      if (_this.currentState === PENDING) {
        _this.currentState = RESOLVED;
        _this.value = value;
        _this.resolvedCallbacks.forEach((cb) => cb());
      }
    });
  };
  _this.reject = function (reason) {
    setTimeout(() => {
      // 异步执⾏，保证执⾏顺序
      if (_this.currentState === PENDING) {
        _this.currentState = REJECTED;
        _this.value = reason;
        _this.rejectedCallbacks.forEach((cb) => cb());
      }
    });
  };
  // ⽤于解决以下问题
  // new Promise(() => throw Error('error))
  try {
    fn(_this.resolve, _this.reject);
  } catch (e) {
    _this.reject(e);
  }
}
MyPromise.prototype.then = function (onResolved, onRejected) {
  var self = this;
  // 规范 2.2.7，then 必须返回⼀个新的 promise
  var promise2;
  // 规范 2.2.onResolved 和 onRejected 都为可选参数
  // 如果类型不是函数需要忽略，同时也实现了透传
  // Promise.resolve(4).then().then((value) => console.log(value))
  onResolved = typeof onResolved === "function" ? onResolved : (v) => v;
  onRejected = typeof onRejected === "function" ? onRejected : (r) => throw r;
  if (self.currentState === RESOLVED) {
    return (promise2 = new MyPromise(function (resolve, reject) {
      // 规范 2.2.4，保证 onFulfilled，onRjected 异步执⾏
      // 所以⽤了 setTimeout 包裹下
      setTimeout(function () {
        try {
          var x = onResolved(self.value);
          resolutionProcedure(promise2, x, resolve, reject);
        } catch (reason) {
          reject(reason);
        }
      });
    }));
  }
  if (self.currentState === REJECTED) {
    return (promise2 = new MyPromise(function (resolve, reject) {
      setTimeout(function () {
        // 异步执⾏onRejected
        try {
          var x = onRejected(self.value);
          resolutionProcedure(promise2, x, resolve, reject);
        } catch (reason) {
          reject(reason);
        }
      });
    }));
  }
  if (self.currentState === PENDING) {
    return (promise2 = new MyPromise(function (resolve, reject) {
      self.resolvedCallbacks.push(function () {
        // 考虑到可能会有报错，所以使⽤ try/catch 包裹
        try {
          var x = onResolved(self.value);
          resolutionProcedure(promise2, x, resolve, reject);
        } catch (r) {
          reject(r);
        }
      });
      self.rejectedCallbacks.push(function () {
        try {
          var x = onRejected(self.value);
          resolutionProcedure(promise2, x, resolve, reject);
        } catch (r) {
          reject(r);
        }
      });
    }));
  }
};
// 规范 2.3
function resolutionProcedure(promise2, x, resolve, reject) {
  // 规范 2.3.1，x 不能和 promise2 相同，避免循环引⽤
  if (promise2 === x) {
    return reject(new TypeError("Error"));
  }
  // 规范 2.3.2
  // 如果 x 为 Promise，状态为 pending 需要继续等待否则执⾏
  if (x instanceof MyPromise) {
    if (x.currentState === PENDING) {
      x.then(function (value) {
        // 再次调⽤该函数是为了确认 x resolve 的
        // 参数是什么类型，如果是基本类型就再次 resolve
        // 把值传给下个 then
        resolutionProcedure(promise2, value, resolve, reject);
      }, reject);
    } else {
      x.then(resolve, reject);
    }
    return;
  }
  // 规范 2.3.3.3.3
  // reject 或者 resolve 其中⼀个执⾏过得话，忽略其他的
  let called = false;
  // 规范 2.3.3，判断 x 是否为对象或者函数
  if (x !== null && (typeof x === "object" || typeof x === "function")) {
    // 规范 2.3.3.2，如果不能取出 then，就 reject
    try {
      // 规范 2.3.3.1
      let then = x.then;
      // 如果 then 是函数，调⽤ x.then
      if (typeof then === "function") {
        // 规范 2.3.3.3
        then.call(
          x,
          (y) => {
            if (called) return;
            called = true;
            // 规范 2.3.3.3.1
            resolutionProcedure(promise2, y, resolve, reject);
          },
          (e) => {
            if (called) return;
            called = true;
            reject(e);
          }
        );
      } else {
        // 规范 2.3.3.4
        resolve(x);
      }
    } catch (e) {
      if (called) return;
      called = true;
      reject(e);
    }
  } else {
    // 规范 2.3.4，x 为基本类型
    resolve(x);
  }
}
```

promise 看这个： <https://blog.shenzjd.com/pages/e1e76b9843736/>

### generator

> Generator 是 ES6 中新增的语法，和 Promise ⼀样，都可以⽤来异步编程

```js
// 使⽤ * 表示这是⼀个 Generator 函数
// 内部可以通过 yield 暂停代码
// 通过调⽤ next 恢复执⾏
function* test() {
  let a = 1 + 2;
  yield 2;
  yield 3;
}
let b = test();
console.log(b.next()); // > { value: 2, done: false }
console.log(b.next()); // > { value: 3, done: false }
console.log(b.next()); // > { value: undefined, done: true }
```

> 从以上代码可以发现，加上 \* 的函数执⾏后拥有了 next 函数，也就是说函数执⾏后返回了⼀个对象。每次调⽤ next 函数可以继续执⾏被暂停的代码。以下是 Generator 函数的简单实现

```js
// cb 也就是编译过的 test 函数
function generator(cb) {
  return (function () {
    var object = {
      next: 0,
      stop: function () {},
    };
    return {
      next: function () {
        var ret = cb(object);
        if (ret === undefined) return { value: undefined, done: true };
        return {
          value: ret,
          done: false,
        };
      },
    };
  })();
}
// 如果你使⽤ babel 编译后可以发现 test 函数变成了这样
function test() {
  var a;
  return generator(function (_context) {
    while (1) {
      switch ((_context.prev = _context.next)) {
        // 可以发现通过 yield 将代码分割成⼏块
        // 每次执⾏ next 函数就执⾏⼀块代码
        // 并且表明下次需要执⾏哪块代码
        case 0:
          a = 1 + 2;
          _context.next = 4;
          return 2;
        case 4:
          _context.next = 6;
          return 3;
        // 执⾏完毕
        case 6:
        case "end":
          return _context.stop();
      }
    }
  });
}
```

### Proxy

> Proxy 是 ES6 中新增的功能，可以⽤来⾃定义对象中的操作

```js
let p = new Proxy(target, handler);
// `target` 代表需要添加代理的对象
// `handler` ⽤来⾃定义对象中的操作
可以很⽅便的使⽤ Proxy 来实现⼀个数据绑定和监听
let onWatch = (obj, setBind, getLogger) => {
  let handler = {
    get(target, property, receiver) {
      getLogger(target, property)
      return Reflect.get(target, property, receiver);
    },
    set(target, property, value, receiver) {
    setBind(value);
      return Reflect.set(target, property, value);
    }
 };
 return new Proxy(obj, handler);
};
let obj = { a: 1 }
let value
let p = onWatch(obj, (v) => {
 value = v
}, (target, property) => {
 console.log(`Get '${property}' = ${target[property]}`);
})
p.a = 2 // bind `value` to `2`
p.a // -> Get 'a' = 2

```

## 浏览器

### 事件机制

事件触发三阶段

- document 往事件触发处传播，遇到注册的捕获事件会触发
- 传播到事件触发处时触发注册的事件
- 从事件触发处往 document 传播，遇到注册的冒泡事件会触发

> 事件触发⼀般来说会按照上⾯的顺序进⾏，但是也有特例，如果给⼀个⽬标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执⾏

```js
// 以下会先打印冒泡然后是捕获
node.addEventListener(
  "click",
  (event) => {
    console.log("冒泡");
  },
  false
);
node.addEventListener(
  "click",
  (event) => {
    console.log("捕获 ");
  },
  true
);
```

### 注册事件

- 通常我们使⽤ addEventListener 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false 。useCapture 决定了注册的事件是捕获事件还是冒泡事件
- ⼀般来说，我们只希望事件只触发在⽬标上，这时候可以使⽤ stopPropagation 来阻⽌事件的进⼀步传播。通常我们认为 stopPropagation 是⽤来阻⽌事件冒泡的，其实该函数也可以阻⽌捕获事件。 stopImmediatePropagation 同样也能实现阻⽌事件，但是还
  能阻⽌该事件⽬标执⾏别的注册事件

```js
node.addEventListener(
  "click",
  (event) => {
    event.stopImmediatePropagation();
    console.log("冒泡");
  },
  false
);
// 点击 node 只会执⾏上⾯的函数，该函数不会执⾏
node.addEventListener(
  "click",
  (event) => {
    console.log("捕获 ");
  },
  true
);
```

### 事件代理

> 如果⼀个节点中的⼦节点是动态⽣成的，那么⼦节点需要注册事件的话应该注册在⽗节点上

```html
<ul id="ul">
  <li>1</li>
  <li>2</li>
  <li>3</li>
  <li>4</li>
  <li>5</li>
</ul>
<script>
  let ul = document.querySelector("#ul");
  ul.addEventListener("click", (event) => {
    console.log(event.target);
  });
</script>
```

- 事件代理的⽅式相对于直接给⽬标注册事件来说，有以下优点
  - 节省内存
  - 不需要给⼦节点注销事件

### Event Loop

> 众所周知 JS 是⻔⾮阻塞单线程语⾔，因为在最初 JS 就是为了和浏览器交互⽽诞⽣的。如果 JS 是⻔多线程的语⾔话，我们在多个线程中处理 DOM 就可能会发⽣问题（⼀个线程中新加节点，另⼀个线程中删除节点）

- JS 在执⾏的过程中会产⽣执⾏环境，这些执⾏环境会被顺序的加⼊到执⾏栈中。如果遇
  到异步的代码，会被挂起并加⼊到 Task （有多种 task ） 队列中。⼀旦执⾏栈为空，
  Event Loop 就会从 Task 队列中拿出需要执⾏的代码并放⼊执⾏栈中执⾏，所以本
  质上来说 JS 中的异步还是同步⾏为

```js
console.log("script start");
setTimeout(function () {
  console.log("setTimeout");
}, 0);
console.log("script end");
```

> 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（ microtask ） 和 宏任务（ macrotask ）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task

```js
console.log("script start");
setTimeout(function () {
  console.log("setTimeout");
}, 0);
new Promise((resolve) => {
  console.log("Promise");
  resolve();
})
  .then(function () {
    console.log("promise1");
  })
  .then(function () {
    console.log("promise2");
  });
console.log("script end");
// script start => Promise => script end => promise1 => promise2 => setTime
```

以上代码虽然 setTimeout 写在 Promise 之前，但是因为 Promise 属于
微任务⽽ setTimeout 属于宏任务

### 微任务

- process.nextTick
- promise
- Object.observe
- MutationObserver

### 宏任务

- script
- setTimeout
- setInterval
- setImmediate
- I/O
- UI rendering

> 宏任务中包括了 script ，浏览器会先执⾏⼀个宏任务，接下来有异步代码的话就先执⾏微任务

所以正确的⼀次 Event loop 顺序是这样的

- 执⾏同步代码，这属于宏任务
- 执⾏栈为空，查询是否有微任务需要执⾏
- 执⾏所有微任务
- 必要的话渲染 UI
- 然后开始下⼀轮 Event loop ，执⾏宏任务中的异步代码

> 通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有⼤量的计算并且需要操作 DOM 的话，为了更快的响应界⾯响应，我们可以把操作 DOM 放⼊微任务中

### Node 中的 Event loop

- Node 中的 Event loop 和浏览器中的不相同
- Node 的 Event loop 分为 6 个阶段，它们会按照顺序反复运⾏

![48cfa8f4c5ff4190b208bc1721e41cfb](https://cdn.jsdelivr.net/gh/wu529778790/image/blog/48cfa8f4c5ff4190b208bc1721e41cfb.png)

#### timer

- timers 阶段会执⾏ setTimeout 和 setInterval
- ⼀个 timer 指定的时间并不是准确时间，⽽是在达到这个时间后尽快执⾏回调，可能会因为系统正在执⾏别的事务⽽延迟

#### I/O

- I/O 阶段会执⾏除了 close 事件，定时器和 setImmediate 的回调

#### poll

- poll 阶段很重要，这⼀阶段中，系统会做两件事情
  - 执⾏到点的定时器
  - 执⾏ poll 队列中的事件
- 并且当 poll 中没有定时器的情况下，会发现以下两件事情
  - 如果 poll 队列不为空，会遍历回调队列并同步执⾏，直到队列为空或者系统限制
  - 如果 poll 队列为空，会有两件事发⽣
  - 如果有 setImmediate 需要执⾏， poll 阶段会停⽌并且进⼊到 check 阶段执⾏ setImmediate
  - 如果没有 setImmediate 需要执⾏，会等待回调被加⼊到队列中并⽴即执⾏回调
  - 如果有别的定时器需要被执⾏，会回到 timer 阶段执⾏回调。

#### check

- check 阶段执⾏ setImmediate

#### close callbacks

- close callbacks 阶段执⾏ close 事件
- 并且在 Node 中，有些情况下的定时器执⾏顺序是随机的

```js
setTimeout(() => {
  console.log("setTimeout");
}, 0);
setImmediate(() => {
  console.log("setImmediate");
});
// 这⾥可能会输出 setTimeout，setImmediate
// 可能也会相反的输出，这取决于性能
// 因为可能进⼊ event loop ⽤了不到 1 毫秒，这时候会执⾏ setImmediate
// 否则会执⾏ setTimeout
```

> 上⾯介绍的都是 macrotask 的执⾏情况， microtask 会在以上每个阶段完成后⽴即执⾏

```js
setTimeout(() => {
  console.log("timer1");
  Promise.resolve().then(function () {
    console.log("promise1");
  });
}, 0);
setTimeout(() => {
  console.log("timer2");
  Promise.resolve().then(function () {
    console.log("promise2");
  });
}, 0);
// 以上代码在浏览器和 node 中打印情况是不同的
// 浏览器中⼀定打印 timer1, promise1, timer2, promise2
// node 中可能打印 timer1, timer2, promise1, promise2
// 也可能打印 timer1, promise1, timer2, promise2
```

> Node 中的 process.nextTick 会先于其他 microtask 执⾏

```js
setTimeout(() => {
  console.log("timer1");
  Promise.resolve().then(function () {
    console.log("promise1");
  });
}, 0);
process.nextTick(() => {
  console.log("nextTick");
});
// nextTick, timer1, promise1
```

### Service Worker

> Service workers 本质上充当 Web 应⽤程序与浏览器之间的代理服务器，也可以在⽹络可⽤时作为浏览器和⽹络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截⽹络请求并基于⽹络是否可⽤以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步 API

⽬前该技术通常⽤来做缓存⽂件，提⾼⾸屏速度

```js
// index.js
if (navigator.serviceWorker) {
  navigator.serviceWorker
    .register("sw.js")
    .then(function (registration) {
      console.log("service worker 注册成功");
    })
    .catch(function (err) {
      console.log("servcie worker 注册失败");
    });
}
// sw.js
// 监听 `install` 事件，回调中缓存所需⽂件
self.addEventListener("install", (e) => {
  e.waitUntil(
    caches.open("my-cache").then(function (cache) {
      return cache.addAll(["./index.html", "./index.js"]);
    })
  );
});
// 拦截所有请求事件
// 如果缓存中已经有请求的数据就直接⽤缓存，否则去请求数据
self.addEventListener("fetch", (e) => {
  e.respondWith(
    caches.match(e.request).then(function (response) {
      if (response) {
        return response;
      }
      console.log("fetch source");
    })
  );
});
```

> 打开⻚⾯，可以在开发者⼯具中的 Application 看到 Service Worker 已经启动了

> 在 Cache 中也可以发现我们所需的⽂件已被缓存

> 当我们重新刷新⻚⾯可以发现我们缓存的数据是从 Service Worker 中读取的

### 渲染机制

浏览器的渲染机制⼀般分为以下⼏个步骤

- 处理 HTML 并构建 DOM 树。
- 处理 CSS 构建 CSSOM 树。
- 将 DOM 与 CSSOM 合并成⼀个渲染树。
- 根据渲染树来布局，计算每个节点的位置
- 调⽤ GPU 绘制，合成图层，显示在屏幕上

> 在构建 CSSOM 树时，会阻塞渲染，直⾄ CSSOM 树构建完成。并且构建 CSSOM 树是⼀个⼗分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执⾏速度越慢

> 当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地⽅重新开始。也就是说，如果你想⾸屏渲染的越快，就越不应该在⾸屏就加载 JS ⽂件。并且 CSS 也会影响 JS 的执⾏，只有当解析完样式表才会执⾏ JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM

### 图层

> ⼀般来说，可以把普通⽂档流看成⼀个图层。特定的属性可以⽣成⼀个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独⽣成⼀个新图层，提⾼性能。但也不能⽣成过多的图层，会引起反作⽤

- 通过以下⼏个常⽤属性可以⽣成新图层
  - 3D 变换： translate3d 、 translateZ
  - will-change
  - video 、 iframe 标签
  - 通过动画实现的 opacity 动画转换
  - position: fixed

### 重绘(Repaint)和回流(Reflow)

- 重绘是当节点需要更改外观⽽不会影响布局的，⽐如改变 color 就叫称为重绘
- 回流是布局或者⼏何属性需要改变就称为回流

> 回流必定会发⽣重绘，重绘不⼀定会引发回流。回流所需的成本⽐重绘⾼的多，改变深层次的节点很可能导致⽗节点的⼀系列回流

- 所以以下⼏个动作可能会导致性能问题：
  - 改变 window ⼤⼩
  - 改变字体
  - 添加或删除样式
  - ⽂字改变
  - 定位或者浮动
  - 盒模型

很多⼈不知道的是，重绘和回流其实和 Event loop 有关

- 当 Event loop 执⾏完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新⼀次。
- 然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是⾄少 16ms 才会触发⼀次，并且⾃带节流功能。
- 判断是否触发了 media query
- 更新动画并且发送事件
- 判断是否有全屏操作事件
- 执⾏ requestAnimationFrame 回调
- 执⾏ IntersectionObserver 回调，该⽅法⽤于判断元素是否可⻅，可以⽤于懒加载上，但是兼容性不好
- 更新界⾯
- 以上就是⼀帧中可能会做的事情。如果在⼀帧中有空闲时间，就会去执⾏ requestIdleCallback 回调

#### 减少重绘和回流

- 使⽤ translate 替代 top
- 使⽤ visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）
- 不要使⽤ table 布局，可能很⼩的⼀个⼩改动会造成整个 table 的重新布局
- 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使⽤ requestAnimationFrame
- CSS 选择符从右往左匹配查找，避免 DOM 深度过深
- 将频繁运⾏的动画变为图层，图层能够阻⽌该节点回流影响别的元素。⽐如对于 video 标签，浏览器会⾃动将该节点变为图层

## 性能

### 1.DNS 预解析

DNS 解析也是需要时间的，可以通过预解析的⽅式来预先获得域名所对应的 IP

```html
<link rel="dns-prefetch" href="//blog.shenzjd.com" />
```

### 2.缓存

- 缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提⾼⽹⻚的整体加载速度
- 通常浏览器缓存策略分为两种：强缓存和协商缓存

#### 强缓存

> 实现强缓存可以通过两种响应头实现： Expires 和 Cache-Control 。强缓存表示在缓存期间不需要请求， state code 为 200

Expires: Wed, 22 Oct 2018 08:41:00 GMT

> Expires 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 201808:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效

Cache-control: max-age=30

> Cache-Control 出现于 HTTP / 1.1 ，优先级⾼于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求

#### 协商缓存

- 如果缓存过期了，我们就可以使⽤协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304
- 协商缓存需要客户端和服务端共同实现，和强缓存⼀样，也有两种实现⽅式

Last-Modified 和 If-Modified-Since

- Last-Modified 表示本地⽂件最后修改⽇期， If-Modified-Since 会将 LastModified 的值发送给服务器，询问服务器在该⽇期后资源是否有更新，有更新的话就会将新的资源发送回来
- 但是如果在本地打开缓存⽂件，就会造成 Last-Modified 被修改，所以在 HTTP /1.1 出现了 ETag

ETag 和 If-None-Match

- ETag 类似于⽂件指纹， If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级⽐ LastModified ⾼

#### 选择合适的缓存策略

> 对于⼤部分的场景都可以使⽤强缓存配合协商缓存解决，但是在⼀些特殊的地⽅可能需要选择特殊的缓存策略

- 对于某些不需要缓存的资源，可以使⽤ Cache-control: no-store ，表示该资源不需要缓存
- 对于频繁变动的资源，可以使⽤ Cache-Control: no-cache 并配合 ETag 使⽤，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新
- 对于代码⽂件来说，通常使⽤ Cache-Control: max-age=31536000 并配合策略缓存使⽤，然后对⽂件进⾏指纹处理，⼀旦⽂件名变动就会⽴刻下载新的⽂件

### 3.使⽤ HTTP / 2.0

- 因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建⽴和断开，消耗了好⼏个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积⼤的⽂件会需要更多的时间
- 在 HTTP / 2.0 中引⼊了多路复⽤，能够让多个请求使⽤同⼀个 TCP 链接，极⼤的加快了⽹⻚的加载速度。并且还⽀持 Header 压缩，进⼀步的减少了请求的数据⼤⼩

### 4.预加载

- 在开发中，可能会遇到这样的情况。有些资源不需要⻢上⽤到，但是希望尽早获取，这时候就可以使⽤预加载
- 预加载其实是声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件，可以使⽤以下代码开启预加载

```html
<link rel="preload" href="http://blog.shenzjd.com" />
```

> 预加载可以⼀定程度上降低⾸屏的加载时间，因为可以将⼀些不影响⾸屏但重要的⽂件延后加载，唯⼀缺点就是兼容性不好

### 5.预渲染

- 可以通过预渲染将下载的⽂件预先在后台渲染，可以使⽤以下代码开启预渲染

```html
<link rel="prerender" href="http://blog.shenzjd.com" />
```

预渲染虽然可以提⾼⻚⾯的加载速度，但是要确保该⻚⾯百分百会被⽤户在之后打开，否
则就⽩⽩浪费资源去渲染

## PDF 下载

<https://docs.qq.com/pdf/DV2ppTWJsVU9odWFu>
