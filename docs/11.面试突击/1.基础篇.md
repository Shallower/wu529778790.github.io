---
title: 基础篇
date: 2022-03-07 14:33:22
permalink: /pages/d4fd303b96708/
categories:
  - 面试突击
tags:
  -
---

【腾讯文档】1、第一部分：基础篇(293 题)

<!-- more -->

## 1. HTML、HTTP、WEB 综合问题

### 1.1 前端需要注意哪些 SEO

- 合理的 title、description、keywords：搜索对这三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过两次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可
- 语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页
- 重要内容 html 代码放在最前：搜索引擎的抓取 HTML 顺序是从上到下，有的时候搜索引擎对抓取长度有限制，保证重要内容一定会被抓取
- 重要内容不要使用 js 输出：爬虫不会执行 js 获取内容
- 少用 iframe：搜索引擎不会抓取 iframe 中的内容
- 非装饰性图片必须加 alt
- 提高网站速度：网站速度是搜索引擎排序的一个重要指标

### 1.2 img 的 title 和 alt 有什么 qubie

- 通常当鼠标滑动到元素上的时候显示
- alt 是 img 特有的属性，是图片显示内容的等价描述，用于图片无法加载时显示。读屏器阅读图片。可提高图片高可访问性，除了纯装饰性图片外都必须设置有意义的值，搜索引擎会重点分析

### 1.3 HTTP 的集中请求方法用途

- GET 方法

发送一个请求来取得服务器的某一资源

- POST 方法

想 URL 指定的资源提交数据或附加新的数据

- PUT 方法

跟 POST 方法很像，也是想服务器提交数据。但是，他们之间有不同。PUT 指定了资源在服务器上的位置，而 post 没有

- HEAD 方法

只请求页面的首部

- DELETE 方法

删除服务器上的某资源

- OPTIONS 方法

它用于获取当前 URL 所支持的方法，如果请求成功，会有一个 ALLOW 的头部包含类似"GET,POST"这样的信息

- TRACE 方法

该方法用于激发一个远程的，应用层的请求消息回路

- CONNECT 方法

把请求连接转换到透明的 TCP/IP 通道

### 1.4 从浏览器地址栏输入 URL 到显示页面的步骤

#### 简略回答

- 浏览器根据请求的 URL 交给 DNS 域名解析，找到真实的 IP，向服务器发送请求
- 服务器交给后台处理完成后返回数据，浏览器接受文件(HTML、JS、CSS、图像等)
- 浏览器对加载到的资源进行语法解析(HTML、JS、CSS、图像等)，建立相应的内部数据结构(如 HTML 的 DOM)
- 载入解析到的资源文件，渲染页面，完成

#### 详细回答

- 在浏览器地址栏输入 URL
- 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤

  1. 如果资源为缓存，发起新请求
  2. 如果已缓存，检查是否新鲜，新鲜则直接提供给客户端，否则与服务器进行验证
  3. 检查是否可用通常有两个 HTTP 头进行控制 Expires 和 Cache-Control

  HTTP1.0 提供 Expires，值为一个绝对时间表示缓存日期

  HTTP1.1 增加了 Cache-Control：max-age=,值为以秒为单位的最大新鲜时间

- 浏览器解析 URL 获取协议，主机，端口，path
- 浏览器组装一个 HTTP 请求报文
- 浏览器获取主机 ip 地址，过程如下：
  1. 浏览器缓存
  2. 本机缓存
  3. hosts 文件
  4. 路由器缓存
  5. ISP DNS 缓存
  6. DNS 递归查询(可能勋在负载均衡导致每次 IP 不一样)
- 打开一个 socket 与目标 ip 地址，端口建立 TCP 链接，三次握手：
  1. 客户端发送一个 TCP 的 SYN=1，Seq=X 的包到服务器端口
  2. 服务器返回 SYN=1，ACK=X+1，Seq=Y 的响应包
  3. 客户端发送 ACK=Y+1，Seq=Z
- TCP 链接建立以后发送 HTTP 请求
- 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用 HTTP Host 头部判断请求的服务程序
- 服务器检查 HTTP 请求头是否包含缓存验证信息，如果验证缓存信息新鲜，返回 304 等对应状态码
- 处理程序读取完整请求并准备 HTTP 响应，可能需要查询数据库等操作
- 服务器将响应报文通过 tcp 链接发送浏览器
- 浏览器接收 HTTP 响应，然后根据情况选择关闭 TCP 连接或者保留重用，关闭 TCP 连接的四次握手如下
  1. 主动方发送 Fin=1,ACK=Z,Seq=X 报文
  2. 被动方发送 ACK=X+1，Seq=Z 报文
  3. 被动方发送 Fin=1，ACK=X，Seq=Y 报文
  4. 主动方发送 ACK=Y，Seq=X 报文
- 浏览器检查响应状态码：是否为 1XX，3XX，4XX，5XX，这些情况处理与 2XX 不同
- 如果资源可缓存，进行缓存
- 对响应进行解码（例如 gzip 压缩）
- 根据资源类型决定如何处理（假设资源类型定位 html 文档）
- 解析 HTML 文档，构建 DOM 树，下载资源，构建 CSSDPOM 树，执行 js 脚本，这些操作没有严格的顺序
- 构建 dom 树

  1. Tokenizing：根据 HTML 规范将字符流解析为标记
  2. Lexing: 词法分析将标记转换为对象并定义属性和规则
  3. DOM construction: 根据 HTML 标记关系并将对象组成 DOM 树

- 解析过程中遇到图片、样式表、JS 文件，启动下载
- 构建 CSSDOM 树：
  1. Tokenizing: 字符流转换成标记流
  2. Node：根据标记创建节点
  3. CSSDOM： 节点创建 CSSOM 树
- 根据 DOM 树和 CSSOM 树构建渲染树
  1. 从 DOM 树的根节点遍历所有可见节点，不可见节点包括 （1）script、meta 这样本身不可见的标签 （2）被 css 隐藏的节点，如 display：none
  2. 对每一个可见节点，找到恰当的 CSSOM 规则并应用
  3. 发布可视节点的内容和计算样式
- js 解析：
  1. 浏览器创建 Document 对象并解析 HTML，将解析到的元素和文本节点添加到文档中，此时 document.readystate 为 loading
  2. HTML 解析器遇到没有 async 和 defer 的 script 时，将他们添加到文档中，然后执行行内或者外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用 document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作 script 和他们之前的文档内容
  3. 当解析器遇到设置了 async 属性的 script 时，开始下载脚本并继续解析文档。脚本会在他下载完成后尽快执行，但是解析器不会停下来等他下载。一步脚本禁止使用 document.write()，他们可以访问自己 script 和之前的文档元素
  4. 当文档完成解析，document.readState 变成 interactive
  5. 所有 defer 脚本会按照在文档中出现的顺序执行，延迟脚本能访问完整文档树，禁止使用 document.write()
  6. 浏览器在 Document 对象上出发 DOMContentLoaded 事件
  7. 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState 变为 complete,window 出发 load 事件
- 显示页面（HTML 解析过程中或逐渐显示页面）

#### 详细简版

1. 从浏览器接受 url 到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）
2. 开启网络线程到发出一个完成的 HTTP 请求(这一部分涉及到 dns 查询，tcp/ip 请求，吴增因特网协议栈等知识)
3. 从服务器接收到请求到对应后台接收到请求(这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等)
4. 后台和前台的 HTTP 交互(这一部分包括 HTTP 头部、响应码、报文结构、cookie 等知识，可以提下静态资源的 cookie 优化，以及编码解码，如 gzip 压缩等)
5. 单独拎出来的缓存问题，HTTP 的缓存(这部分包括 http 缓存头部，Etag，Catch-control 等)
6. 浏览器接收到 HTTP 数据包后的解析流程(解析 html-词法分析然后解析成 dom 树、解析 css 生成 css 规则树、合并成 render 树，然后 layout、painting 渲染、复合涂层的合成、GPU 绘制、外联资源的处理、loaded 和 COMContentLoaded 等)
7. CSS 的可视化格式模型(元素的渲染规则，如包含块，控制狂，BFC，IFC 等概念)
8. JS 引擎解析过程(JS 的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、垃圾回收机制等等)
9. 其他(可以扩展下不同的知识模块，如跨域，web 安全，hybrid 模式等等内容)

### 1.5 如何进行网站性能优化

#### content 方面

- 减少 HTTP 请求：合并文件、css 图片精灵、inline Image
- 减少 DNS 查询：DNS 缓存、将资源分布到恰当数量的主机名
- 减少 DOM 元素数量

#### Server 方面

- 使用 CDN
- 配置 Etag
- 对组件使用 Gzip 压缩

#### Cookie 方法

- 减少 cookie 大小

#### css 方面

- 将样式表放到页面顶部
- 不适用 css 表达式
- 使用 link 不适用 import

#### js 方面

- 将脚本放到页面底部
- 将 js 和 css 从外部引入
- 压缩 js 和 css
- 删除不需要的脚本
- 减少 DOM 访问

#### 图片方面

- 优化图片： 根据实际颜色需要选择色深、压缩
- 优化 css 精灵
- 不要再 html 中拉伸图片

### 1.6 HTTP 状态码以及含义

#### 1XX：信息状态码

- 100 continue 继续，一般在发送 post 请求时，已发送了 http header 之后服务端将返回此信息，表示确认，之后发送具体参数信息

#### 2XX：成功状态码

- 200 OK 正常返回信息
- 201 Created 请求成功并且服务器创建了新的资源
- 202 Accepted 服务器已接收请求，但尚未处理

#### 3XX： 重定向

- 301 Moved Permanently 请求的网页已永久移动到新位置
- 302 Found 临时重定向
- 303 See Other 临时重定向，且总是使用 GET 请求新的 URI
- 304 Not Modified 自从上次请求后，请求的网页未修改过

#### 4XX：客户端错误

- 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求
- 401 Unauthorized 请求未授权
- 403 Forbidden 禁止访问
- 404 Not Found 找不到如何与 URI 相匹配的资源

#### 5XX：服务器错误

- 500 Internal Server Error 最常见的服务器端错误
- 503 Service Unavailabel 服务器端暂时无法处理请求（可能是过载或维护）

### 1.7 语义化的理解

- 用正确的标签做正确的事情
- HTML 语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析
- 在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的
- 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO
- 使阅读源代码的人对网站更容易将网站分块，便于理解维护

### 1.8 浏览器内核

- 主要分成两个部分：渲染引擎(layout engineer 或 Rendering Engine)和 js 引擎
- 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 css 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其他需要编辑、显式网略内容的应用程序都需要内核
- js 引擎规则：解析和执行 js 来实现网页的动态效果
- 最开始渲染引擎和 js 引擎并没有区分的很明显，后来 js 引擎越来越独立，内核就倾向于只指渲染引擎

### 1.9 html5 有哪些新特性、移除了哪些元素？

- HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加
  - 绘画 canvas
  - ⽤于媒介回放的 video 和 audio 元素
  - 本地离线存储 localStorage ⻓期存储数据，浏览器关闭后数据不丢失
  - sessionStorage 的数据在浏览器关闭后⾃动删除
  - 语意化更好的内容元素，⽐如 article 、 footer 、 header 、 nav 、 section
  - 表单控件， calendar 、 date 、 time 、 email 、 url 、 search
  - 新的技术 webworker 、 websocket 、 Geolocation
- 移除的元素：
  - 纯表现的元素： basefont 、 big 、 center 、 font 、 s 、 strike 、 tt 、 u
  - 对可⽤性产⽣负⾯影响的元素： frame 、 frameset 、 noframes
- ⽀持 HTML5 新标签：
  - IE8/IE7/IE6 ⽀持通过 document.createElement ⽅法产⽣的标签
  - 可以利⽤这⼀特性让这些浏览器⽀持 HTML5 新标签
  - 浏览器⽀持新标签后，还需要添加标签默认的样式
- 当然也可以直接使⽤成熟的框架、⽐如 html5shim

### 1.10 HTML5 的离线储存怎么使⽤，⼯作原理能不能解释⼀下

- 在⽤户没有与因特⽹连接时，可以正常访问站点或应⽤，在⽤户与因特⽹连接时，更新⽤户机器上的缓存⽂件
- 原理： HTML5 的离线存储是基于⼀个新建的 .appcache ⽂件的缓存机制(不是存储技术)，通过这个⽂件上的解析清单离线存储资源，这些资源就会像 cookie ⼀样被存储了下来。之后当⽹络在处于离线状态下时，浏览器会通过被离线存储的数据进⾏⻚⾯展示
- 如何使⽤：
  - ⻚⾯头部像下⾯⼀样加⼊⼀个 manifest 的属性；
  - 在 cache.manifest ⽂件的编写离线存储的资源
  - 在离线状态时，操作 window.applicationCache 进⾏需求实现

### 1.11 浏览器是怎么对 HTML5 的离线储存资源进⾏管理和加载的呢

- 在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest ⽂件，如果是第⼀次访问 app ，那么浏览器就会根据 manifest ⽂件的内容下载相应的资源并且进⾏离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使⽤离线的资源加载⻚⾯，然后浏览器会对⽐新的 manifest ⽂件与旧的 manifest ⽂件，如果⽂件没有发⽣改变，就不做任何操作，如果⽂件改变了，那么就会重新下载⽂件中的资源并进⾏离线存储
- 离线的情况下，浏览器就直接使⽤离线存储的资源

### 请描述⼀下 cookies ， sessionStorage 和 localStorage 的区别

- cookie 是⽹站为了标示⽤户身份⽽储存在⽤户本地终端（Client Side）上的数据（通常经过加密）
- cookie 数据始终在同源的 http 请求中携带（即使不需要），记会在浏览器和服务器间来回传递
- sessionStorage 和 localStorage 不会⾃动把数据发给服务器，仅在本地保存
- 存储⼤⼩：
  - cookie 数据⼤⼩不能超过 4k
  - sessionStorage 和 localStorage 虽然也有存储⼤⼩的限制，但⽐ cookie ⼤得多，可以达到 5M 或更⼤
- 有期时间：
  - localStorage 存储持久数据，浏览器关闭后数据不丢失除⾮主动删除数据
  - sessionStorage 数据在当前浏览器窗⼝关闭后⾃动删除
  - cookie 设置的 cookie 过期时间之前⼀直有效，即使窗⼝或浏览器关闭

### 1.13 iframe 有那些缺点

- iframe 会阻塞主⻚⾯的 Onload 事件
- 搜索引擎的检索程序⽆法解读这种⻚⾯，不利于 SEO
- iframe 和主⻚⾯共享连接池，⽽浏览器对相同域的连接有限制，所以会影响⻚⾯的并⾏加载
- 使⽤ iframe 之前需要考虑这两个缺点。如果需要使⽤ iframe ，最好是通过 javascript 动态给 iframe 添加 src 属性值，这样可以绕开以上两个问题

### 1.14 WEB 标准以及 W3C 标准是什么

- 标签闭合、标签⼩写、不乱嵌套、使⽤外链 css 和 js 、结构⾏为表现的分离

### 1.15 xhtml 和 html 有什么区别

- xhtml 和 html 有什么区别
  - 主要是 XHTML 可兼容各⼤浏览器、⼿机以及 PDA ，并且浏览器也能快速正确地编译⽹⻚
- 另外是书写习惯的差别
  - XHTML 元素必须被正确地嵌套，闭合，区分⼤⼩写，⽂档必须拥有根元素

### 1.16 Doctype 作⽤? 严格模式与混杂模式如何区分？它们有何意义

- ⻚⾯被加载的时， link 会同时被加载，⽽ @imort ⻚⾯被加载的时， link 会同时被加载，⽽ @import 引⽤的 CSS 会等到⻚⾯被加载完再加载 import 只在 IE5 以上才能识别，⽽ link 是 XHTML 标签，⽆兼容问题 link ⽅式的样式的权重 ⾼于 @import 的权重
- \<!DOCTYPE\> 声明位于⽂档中的最前⾯，处于 \<html\> 标签之前。告知浏览器的解析器， ⽤什么⽂档类型 规范来解析这个⽂档
- 严格模式的排版和 JS 运作模式是 以该浏览器⽀持的最⾼标准运⾏
- 在混杂模式中，⻚⾯以宽松的向后兼容的⽅式显示。模拟⽼式浏览器的⾏为以防⽌站点⽆法⼯作。 DOCTYPE 不存在或格式不正确会导致⽂档以混杂模式呈现

### 1.17 ⾏内元素有哪些？块级元素有哪些？ 空(void)元素有那些？⾏内元素和块级元素有什么区别

- ⾏内元素有： a b span img input select strong
- 块级元素有： div ul ol li dl dt dd h1 h2 h3 h4… p
- 空元素： \<br> \<hr> \<img> \<input> \<link> \<meta>
- ⾏内元素不可以设置宽⾼，不独占⼀⾏
- 块级元素可以设置宽⾼，独占⼀⾏

### 1.18 HTML 全局属性(global attribute)有哪些

- class :为元素设置类标识
- data-\* : 为元素增加⾃定义属性
- draggable : 设置元素是否可拖拽
- id : 元素 id ，⽂档内唯⼀
- lang : 元素内容的的语⾔
- style : ⾏内 css 样式
- title : 元素相关的建议信息

### 1.19 Canvas 和 SVG 有什么区别？

- svg 绘制出来的每⼀个图形的元素都是独⽴的 DOM 节点，能够⽅便的绑定事件或⽤来修改。 canvas 输出的是⼀整幅画布
- svg 输出的图形是⽮量图形，后期可以修改参数来⾃由放⼤缩⼩，不会失真和锯⻮。⽽ canvas 输出标量画布，就像⼀张图⽚⼀样，放⼤会失真或者锯⻮

### 1.20 HTML5 为什么只需要写 \<!DOCTYPE HTML\>

- HTML5 不基于 SGML ，因此不需要对 DTD 进⾏引⽤，但是需要 doctype 来规范浏览器的⾏为
- ⽽ HTML4.01 基于 SGML ,所以需要对 DTD 进⾏引⽤，才能告知浏览器⽂档所使⽤的⽂档类型

### 1.21 如何在⻚⾯上实现⼀个圆形的可点击区域？

- svg
- border-radius
- 纯 js 实现 需要求⼀个点在不在圆上简单算法、获取⿏标坐标等等

### 1.22 ⽹⻚验证码是⼲嘛的，是为了解决什么安全问题

- 区分⽤户是计算机还是⼈的公共全⾃动程序。可以防⽌恶意破解密码、刷票、论坛灌⽔
- 有效防⽌⿊客对某⼀个特定注册⽤户⽤特定程序暴⼒破解⽅式进⾏不断的登陆尝试

### 1.23 viewport

```html
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<!-- width 设置viewport宽度，为⼀个正整数，或字符串‘device-width’
 device-width 设备宽度
 height 设置viewport⾼度，⼀般设置了宽度，会⾃动解析出⾼度，可以不⽤设置
 initial-scale 默认缩放⽐例（初始缩放⽐例），为⼀个数字，可以带⼩数
 minimum-scale 允许⽤户最⼩缩放⽐例，为⼀个数字，可以带⼩数
 maximum-scale 允许⽤户最⼤缩放⽐例，为⼀个数字，可以带⼩数
 user-scalable 是否允许⼿动缩放 -->
```

> 怎样处理 移动端 1px 被 渲染成 2px 问题

- 局部处理
  - mate 标签中的 viewport 属性 ， initial-scale 设置为 1
  - rem 按照设计稿标准⾛，外加利⽤ transfrome 的 scale(0.5) 缩⼩⼀倍即可；
- 全局处理
  - mate 标签中的 viewport 属性 ， initial-scale 设置为 0.5
  - rem 按照设计稿标准⾛即可

### 1.24 渲染优化

- 禁⽌使⽤ iframe （阻塞⽗⽂档 onload 事件）
  - iframe 会阻塞主⻚⾯的 Onload 事件
  - 搜索引擎的检索程序⽆法解读这种⻚⾯，不利于 SEO
  - iframe 和主⻚⾯共享连接池，⽽浏览器对相同域的连接有限制，所以会影响⻚⾯的并⾏加载
  - 使⽤ iframe 之前需要考虑这两个缺点。如果需要使⽤ iframe ，最好是通过 javascript 动态给 iframe 添加 src 属性值，这样可以绕开以上两个问题
- 禁⽌使⽤ gif 图⽚实现 loading 效果（降低 CPU 消耗，提升渲染性能）
- 使⽤ CSS3 代码代替 JS 动画（尽可能避免重绘重排以及回流）
- 对于⼀些⼩图标，可以使⽤ base64 位编码，以减少⽹络请求。但不建议⼤图使⽤，⽐较耗费 CPU
  - ⼩图标优势在于
    - 减少 HTTP 请求
    - 避免⽂件跨域
    - 修改及时⽣效
- ⻚⾯头部的 \<style></style> \<script></script> 会阻塞⻚⾯；（因为 Renderer 进程中 JS 线程和渲染线程是互斥的）
- ⻚⾯中空的 href 和 src 会阻塞⻚⾯其他资源的加载 (阻塞下载进程)
- ⽹⻚ gzip ， CDN 托管， data 缓存 ，图⽚服务器
- 前端模板 JS+数据，减少由于 HTML 标签导致的带宽浪费，前端⽤变量保存 AJAX 请求结果，每次操作本地变量，不⽤请求，减少请求次数
- ⽤ innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能
- 当需要设置的样式很多时设置 className ⽽不是直接操作 style 少⽤全局变量、缓存 DOM 节点查找的结果。减少 IO 读取操作
- 图⽚预加载，将样式表放在顶部，将脚本放在底部 加上时间戳
- 对普通的⽹站有⼀个统⼀的思路，就是尽量向前端优化、减少数据库操作、减少磁盘 IO

### 1.25 meta viewport 相关

```html
<!DOCTYPE html>
<!--H5标准声明，使⽤ HTML5 doctype，不区分⼤⼩写-->
<head lang="”en”">
  <!--标准的 lang 属性写法-->
  <meta charset="’utf-8′" />
  <!--声明⽂档使⽤的字符编码-->
  <meta http-equiv="”X-UA-Compatible”" content="”IE" ="edge,chrome" ="1″" />
  <!--优先使
<meta name=”description” content=”不超过150个字符”/> <!--⻚⾯描述-->
  <meta name="”keywords”" content="””" />
  <!-- ⻚⾯关键词-->
  <meta name="”author”" content="”name," email@gmail.com” />
  <!--⽹⻚作者-->
  <meta name="”robots”" content="”index,follow”" />
  <!--搜索引擎抓取-->
  <meta
    name="”viewport”"
    content="”initial-scale"
    ="1,"
    maximum-scale="3,"
    minimum-sc
    <meta
    name="”apple-mobile-web-app-title”"
    content="”标题”"
  />
  <!--iOS 设备 begin-->
  <meta name="”apple-mobile-web-app-capable”" content="”yes”" />
  <!--添加到主屏后的标
是否启⽤ WebApp 全屏模式，删除苹果默认的⼯具栏和菜单栏-->
  <meta
    name="”apple-itunes-app”"
    content="”app-id"
    ="myAppStoreID,"
    affiliate-data="<!--添加智能"
    App
    ⼴告条
    Smart
    App
    Banner（iOS
    6+
    Safari）--
  />
  <meta name="”apple-mobile-web-app-status-bar-style”" content="”black”" />
  <meta name="”format-detection”" content="”telphone" ="no," email="no”" />
  <!--设置苹果
<meta name=”renderer” content=”webkit”> <!-- 启⽤360浏览器的极速模式(webkit)-->
  <meta http-equiv="”X-UA-Compatible”" content="”IE" ="edge”" />
  <!--避免IE使⽤兼容模
<meta http-equiv=”Cache-Control” content=”no-siteapp” /> <!--不让百度转码-
<meta name=”HandheldFriendly” content=”true”> <!--针对⼿持设备优化，主要是针
<meta name=”MobileOptimized” content=”320″> <!--微软的⽼式浏览器-->
  <meta name="”screen-orientation”" content="”portrait”" />
  <!--uc强制竖屏-->
  <meta name="”x5-orientation”" content="”portrait”" />
  <!--QQ强制竖屏-->
  <meta name="”full-screen”" content="”yes”" />
  <!--UC强制全屏-->
  <meta name="”x5-fullscreen”" content="”true”" />
  <!--QQ强制全屏-->
  <meta name="”browsermode”" content="”application”" />
  <!--UC应⽤模式-->
  <meta name="”x5-page-mode”" content="”app”" />
  <!-- QQ应⽤模式-->
  <meta name="”msapplication-tap-highlight”" content="”no”" />
  <!--windows phone 设置⻚⾯不缓存-->
  <meta http-equiv="”pragma”" content="”no-cache”" />
  <meta http-equiv="”cache-control”" content="”no-cache”" />
  <meta http-equiv="”expires”" content="”0″" />
</head>
```

### 1.26 你做的⻚⾯在哪些流览器测试过？这些浏览器的内核分别是什么

- IE : trident 内核
- Firefox ： gecko 内核
- Safari : webkit 内核
- Opera :以前是 presto 内核， Opera 现已改⽤ Google - Chrome 的 Blink 内核
- Chrome:Blink (基于 webkit ，Google 与 Opera Software 共同开发)

### 1.27 div+css 的布局较 table 布局有什么优点

- 改版的时候更⽅便 只要改 css ⽂件。
- ⻚⾯加载速度更快、结构化清晰、⻚⾯显示简洁。
- 表现与结构相分离。
- 易于优化（ seo ）搜索引擎更友好，排名更容易靠前。

### 1.28 a：img 的 alt 与 title 有何异同？b：strong 与 em 的异同

- alt(alt text) :为不能显示图像、窗体或 applets 的⽤户代理（ UA ）， alt 属性⽤来指定替换⽂字。替换⽂字的语⾔由 lang 属性指定。(在 IE 浏览器下会在没有 title 时把 alt 当成 tool tip 显示)
- title(tool tip) :该属性为设置该属性的元素提供建议性的信息
- strong :粗体强调标签，强调，表示内容的重要性
- em :斜体强调标签，更强烈强调，表示内容的强调点

### 1.29 你能描述⼀下渐进增强和优雅降级之间的不同吗

- 渐进增强：针对低版本浏览器进⾏构建⻚⾯，保证最基本的功能，然后再针对⾼级浏览器进⾏效果、交互等改进和追加功能达到更好的⽤户体验。
- 优雅降级：⼀开始就构建完整的功能，然后再针对低版本浏览器进⾏兼容。

> 区别：优雅降级是从复杂的现状开始，并试图减少⽤户体验的供给，⽽渐进增强则是从⼀个⾮常基础的，能够起作⽤的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；⽽渐进增强则意味着朝前看，同时保证其根基处于安全地带

### 1.30 为什么利⽤多个域名来存储⽹站资源会更有效

- CDN 缓存更⽅便
- 突破浏览器并发限制
- 节约 cookie 带宽
- 节约主域名的连接数，优化⻚⾯响应速度
- 防⽌不必要的安全问题

### 1.31 简述⼀下 src 与 href 的区别

- src ⽤于替换当前元素，href ⽤于在当前⽂档和引⽤资源之间确⽴联系。
- src 是 source 的缩写，指向外部资源的位置，指向的内容将会嵌⼊到⽂档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应⽤到⽂档内，例如 js 脚本，img 图⽚和 frame 等元素

> \<script src ="js.js"></script> 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，图⽚和框架等元素也如此，类似于将所指向资源嵌⼊当前标签内。这也是为什么将 js 脚本放在底部⽽不是头部

- href 是 Hypertext Reference 的缩写，指向⽹络资源所在位置，建⽴和当前元素（锚点）或当前⽂档（链接）之间的链接，如果我们在⽂档中添加
  \<link href="common.css" rel="stylesheet"/> 那么浏览器会识别该⽂档为 css ⽂件，就会并⾏下载资源并且不会停⽌对当前⽂档的处理。这也是为什么建议使⽤ link ⽅式来加载 css ，⽽不是使⽤ @import ⽅式

### 1.32 知道的⽹⻚制作会⽤到的图⽚格式有哪些

- png-8 、 png-24 、 jpeg 、 gif 、 svg

> 但是上⾯的那些都不是⾯试官想要的最后答案。⾯试官希望听到是 Webp , Apng 。（是否有关注新技术，新鲜事物）

- Webp： WebP 格式，⾕歌（google）开发的⼀种旨在加快图⽚加载速度的图⽚格式。图⽚压缩体积⼤约只有 JPEG 的 2/3 ，并能节省⼤量的服务器带宽资源和数据空间。Facebook Ebay 等知名⽹站已经开始测试并使⽤ WebP 格式。
- 在质量相同的情况下，WebP 格式图像的体积要⽐ JPEG 格式图像⼩ 40% 。
- Apng：全称是 “Animated Portable Network Graphics” , 是 PNG 的位图动画扩展，可以实现 png 格式的动态图⽚效果。04 年诞⽣，但⼀直得不到各⼤浏览器⼚商的⽀持，直到⽇前得到 iOS safari 8 的⽀持，有望代替 GIF 成为下⼀代动态图标准

### 1.32 在 css/js 代码上线之后开发⼈员经常会优化性能，从⽤户刷新⽹⻚开始，⼀次 js 请求⼀般情况下有哪些地⽅会有缓存处理

> dns 缓存， cdn 缓存，浏览器缓存，服务器缓存

### 1.33 ⼀个⻚⾯上有⼤量的图⽚（⼤型电商⽹站），加载很慢，你有哪些⽅法优化这些图⽚的加载，给⽤户更好的体验

- 图⽚懒加载，在⻚⾯上的未可视区域可以添加⼀个滚动事件，判断图⽚位置与浏览器顶端的距离与⻚⾯的距离，如果前者⼩于后者，优先加载。
- 如果为幻灯⽚、相册等，可以使⽤图⽚预加载技术，将当前展示图⽚的前⼀张和后⼀张优先下载。
- 如果图⽚为 css 图⽚，可以使⽤ CSSsprite ， SVGsprite ， Iconfont 、 Base64 等技术。
- 如果图⽚过⼤，可以使⽤特殊编码的图⽚，加载时会先加载⼀张压缩的特别厉害的缩略图，以提⾼⽤户体验。
- 如果图⽚展示区域⼩于图⽚的真实⼤⼩，则因在服务器端根据业务需要先⾏进⾏图⽚压缩，图⽚压缩后⼤⼩与展示⼀致

### 1.34 常⻅排序算法的时间复杂度,空间复杂度

![46147c7c921641a691daa9fcb69661fd](https://cdn.jsdelivr.net/gh/wu529778790/image/blog/46147c7c921641a691daa9fcb69661fd.png)

### 1.35 web 开发中会话跟踪的⽅法有哪些

- cookie
- session
- url 重写
- 隐藏 input
- ip 地址

### 1.36 HTTP request 报⽂结构是怎样的

1. ⾸⾏是 Request-Line 包括：请求⽅法，请求 URI，协议版本，CRLF
2. ⾸⾏之后是若⼲⾏请求头，包括 general-header，request-header 或者 entity-header，每个⼀⾏以 CRLF 结束
3. 请求头和消息实体之间有⼀个 CRLF 分隔
4. 根据实际请求需要可能包含⼀个消息实体 ⼀个请求报⽂例⼦如下：

```json
GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1
Host: www.w3.org
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML,
Referer: https://www.google.com.hk/
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6
Cookie: authorstyle=yes
If-None-Match: "2cc8-3e3073913b100"
If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT
name=qiu&age=25
```

### 1.37 HTTP response 报⽂结构是怎样的

- ⾸⾏是状态⾏包括：HTTP 版本，状态码，状态描述，后⾯跟⼀个 CRLF
- ⾸⾏之后是若⼲⾏响应头，包括：通⽤头部，响应头部，实体头部
- 响应头部和响应实体之间⽤⼀个 CRLF 空⾏分隔
- 最后是⼀个可能的消息实体 响应报⽂例⼦如下：

```json
HTTP/1.1 200 OK
Date: Tue, 08 Jul 2014 05:28:43 GMT
Server: Apache/2
Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT
ETag: "40d7-3e3073913b100"
Accept-Ranges: bytes
Content-Length: 16599
Cache-Control: max-age=21600
Expires: Tue, 08 Jul 2014 11:28:43 GMT
P3P: policyref="http://www.w3.org/2001/05/P3P/p3p.xml"
Content-Type: text/html; charset=iso-8859-1
{"name": "qiu", "age": 25}
```

## 2. CSS

### 2.1 css sprite 是什么,有什么优缺点

- 概念：将多个⼩图⽚拼接到⼀个图⽚中。通过 background-position 和元素尺⼨调节需要显示的背景图案。
- 优点：
  - 减少 HTTP 请求数，极⼤地提⾼⻚⾯加载速度
  - 增加图⽚信息重复度，提⾼压缩⽐，减少图⽚⼤⼩
  - 更换⻛格⽅便，只需在⼀张或⼏张图⽚上修改颜⾊或样式即可实现
- 缺点：
  - 图⽚合并麻烦
  - 维护麻烦，修改⼀个图⽚可能需要从新布局整个图⽚，样式

### 2.2 display: none; 与 visibility: hidden; 的区别

- 联系：它们都能让元素不可⻅
- 区别：
  - display:none ;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden ;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可⻅
  - display: none ;是⾮继承属性，⼦孙节点消失由于元素从渲染树消失造成，通过修改⼦孙节点属性⽆法显示 ；visibility: hidden; 是继承属性，⼦孙节点消失由于继承了 hidden ，通过设置 visibility: visible; 可以让⼦孙节点显式
  - 修改常规流中元素的 display 通常会造成⽂档重排。修改 visibility 属性只会造成本元素的重绘。
  - 读屏器不会读取 display: none ;元素内容；会读取 visibility: hidden; 元素内容

### 2.3 link 与 @import 的区别

1. link 是 HTML ⽅式， @import 是 CSS ⽅式
2. link 最⼤限度⽀持并⾏下载， @import 过多嵌套导致串⾏下载，出现 FOUC (⽂档样式短暂失效)
3. link 可以通过 rel="alternate stylesheet" 指定候选样式
4. 浏览器对 link ⽀持早于 @import ，可以使⽤ @import 对⽼浏览器隐藏样式
5. @import 必须在样式规则之前，可以在 css ⽂件中引⽤其他⽂件
6. 总体来说： link 优于 @import

### 2.4 什么是 FOUC?如何避免

- Flash Of Unstyled Content ：⽤户定义样式表加载之前浏览器使⽤默认样式显示⽂档，⽤户样式加载渲染之后再从新显示⽂档，造成⻚⾯闪烁。
- 解决⽅法：把样式表放到⽂档的 \<head>

### 2.5 如何创建块级格式化上下⽂(block formatting context),BFC 有什么⽤

- 创建规则：
  - 根元素
  - 浮动元素（ float 不取值为 none ）
  - 绝对定位元素（ position 取值为 absolute 或 fixed ）
  - display 取值为 inline-block 、 table-cell 、 table-caption 、 flex 、
  - inline-flex 之⼀的元素
  - overflow 不取值为 visible 的元素
- 作用
  - 可以包含浮动元素
  - 不被浮动元素覆盖
  - 阻⽌⽗⼦元素的 margin 折叠

### 2.6 display、float、position 的关系

- 如果 display 取值为 none ，那么 position 和 float 都不起作⽤，这种情况下元素不产⽣框
- 否则，如果 position 取值为 absolute 或者 fixed ，框就是绝对定位的， float 的计算值为 none ， display 根据下⾯的表格进⾏调整。
- 否则，如果 float 不是 none ，框是浮动的， display 根据下表进⾏调整
- 否则，如果元素是根元素， display 根据下表进⾏调整
- 其他情况下 display 的值为指定值
- 总结起来：绝对定位、浮动、根元素都需要调整 display

### 2.7 清除浮动的⼏种⽅式，各⾃的优缺点

- ⽗级 div 定义 height
- 结尾处加空 div 标签 clear:both
- ⽗级 div 定义伪类 :after 和 zoom
- ⽗级 div 定义 overflow:hidden
- ⽗级 div 也浮动，需要定义宽度
- 结尾处加 br 标签 clear:both

> ⽐较好的是第 3 种⽅式，好多⽹站都这么⽤

### 2.8 为什么要初始化 CSS 样式

- 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对 CSS 初始化往往会出现浏览器之间的⻚⾯显示差异。
- 当然，初始化样式会对 SEO 有⼀定的影响，但⻥和熊掌不可兼得，但⼒求影响最⼩的情况下初始化

### 2.9 css3 有哪些新特性

- 新增各种 css 选择器
- 圆⻆ border-radius
- 多列布局
- 阴影和反射
- ⽂字特效 text-shadow
- 线性渐变
- 旋转 transform

#### CSS3 新增伪类有那些？

- p:first-of-type 选择属于其⽗元素的⾸个 \<p> 元素的每个 \<p> 元素。
- p:last-of-type 选择属于其⽗元素的最后 \<p> 元素的每个 \<p> 元素。
- p:only-of-type 选择属于其⽗元素唯⼀的 \<p> 元素的每个 \<p> 元素。
- p:only-child 选择属于其⽗元素的唯⼀⼦元素的每个 \<p> 元素。
- p:nth-child(2) 选择属于其⽗元素的第⼆个⼦元素的每个 \<p> 元素。
- :after 在元素之前添加内容,也可以⽤来做清除浮动。
- :before 在元素之后添加内容。
- :enabled 已启⽤的表单元素。
- :disabled 已禁⽤的表单元素。
- :checked 单选框或复选框被选中

### 2.10 display 有哪些值？说明他们的作⽤

- block 转换成块状元素。
- inline 转换成⾏内元素。
- none 设置元素不可⻅。
- inline-block 象⾏内元素⼀样显示，但其内容象块类型元素⼀样显示。
- list-item 象块类型元素⼀样显示，并添加样式列表标记。
- table 此元素会作为块级表格来显示
- inherit 规定应该从⽗元素继承 display 属性的值

### 2.11 介绍⼀下标准的 CSS 的盒⼦模型？低版本 IE 的盒⼦模型有什么不同的

- 有两种， IE 盒⼦模型、 W3C 盒⼦模型；
- 盒模型： 内容(content)、填充( padding )、边界( margin )、 边框( border )；
- 区 别： IE 的 c ontent 部分把 border 和 padding 计算了进去

### 2.12 CSS 优先级算法如何计算？

- 优先级就近原则，同权重情况下样式定义最近者为准
- 载⼊样式以最后载⼊的定位为准
- 优先级为: !important > id > class > tag ; !important ⽐ 内联优先级⾼

### 2.13 对 BFC 规范的理解？

- 它决定了元素如何对其内容进⾏定位,以及与其他元素的关系和相互作⽤

### 2.14 谈谈浮动和清除浮动

- 浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另⼀个浮动框的边框为⽌。由于浮动框不在⽂档的普通流中，所以⽂档的普通流的块框表现得就像浮动框不存在⼀样。浮动的块框会漂浮在⽂档普通流的块框上

### 2.15 position 的值， relative 和 absolute 定位原点是

- absolute ：⽣成绝对定位的元素，相对于 static 定位以外的第⼀个⽗元素进⾏定位
- fixed ：⽣成绝对定位的元素，相对于浏览器窗⼝进⾏定位
- relative ：⽣成相对定位的元素，相对于其正常位置进⾏定位
- static 默认值。没有定位，元素出现在正常的流中
- inherit 规定从⽗元素继承 position 属性的值

### 2.16 display:inline-block 什么时候不会显示间隙？(携程)

- 移除空格
- 使⽤ margin 负值
- 使⽤ font-size:0
- letter-spacing
- word-spacing

### 2.17 PNG\GIF\JPG 的区别及如何选

- GIF
  - 8 位像素， 256 ⾊
  - ⽆损压缩
  - ⽀持简单动画
  - ⽀持 boolean 透明
  - 适合简单动画
- JPEG
  - 颜⾊限于 256
  - 有损压缩
  - 可控制压缩质量
  - 不⽀持透明
  - 适合照⽚
- PNG
  - 有 PNG8 和 truecolor PNG
  - PNG8 类似 GIF 颜⾊上限为 256 ，⽂件⼩，⽀持 alpha 透明度，⽆动画
  - 适合图标、背景、按钮

### 2.18 ⾏内元素 float:left 后是否变为块级元素？

> ⾏内元素设置成浮动之后变得更加像是 inline-block （⾏内块级元素，设置成这个属性的元素会同时拥有⾏内和块级的特性，最明显的不同是它的默认宽度不是 100% ），这时候给⾏内元素设置 padding-top 和 padding-bottom 或者 width 、 height 都是有效果的

### 2.19 在⽹⻚中的应该使⽤奇数还是偶数的字体？为什么呢？

- 偶数字号相对更容易和 web 设计的其他部分构成⽐例关系

### 2.20 ::before 和 :after 中双冒号和单冒号 有什么区别？解释⼀下这 2 个伪元素的作⽤

- 单冒号( : )⽤于 CSS3 伪类，双冒号( :: )⽤于 CSS3 伪元素
- ⽤于区分伪类和伪元素

### 2.21 如果需要⼿动写动画，你认为最⼩时间间隔是多久，为什么？（阿⾥）

- 多数显示器默认频率是 60Hz ，即 1 秒刷新 60 次，所以理论上最⼩间隔为 `1/60*1000ms ＝ 16.7ms`

### 2.22 CSS 合并⽅法

- 避免使⽤ @import 引⼊多个 css ⽂件，可以使⽤ CSS ⼯具将 CSS 合并为⼀个 CSS ⽂件，例如使⽤ Sass\Compass 等

### 2.23 CSS 不同选择器的权重(CSS 层叠的规则)

- ！important 规则最重要，⼤于其它规则
- ⾏内样式规则，加 1000
- 对于选择器中给定的各个 ID 属性值，加 100
- 对于选择器中给定的各个类属性、属性选择器或者伪类选择器，加 10
- 对于选择其中给定的各个元素标签选择器，加 1
- 如果权值⼀样，则按照样式规则的先后顺序来应⽤，顺序靠后的覆盖靠前的规则

### 2.24 列出你所知道可以改变⻚⾯布局的属性

- position 、 display 、 float 、 width 、 height 、 margin 、 padding 、top 、 left 、 right

### 2.25 CSS 在性能优化⽅⾯的实践

- css 压缩与合并、 Gzip 压缩
- css ⽂件放在 head ⾥、不要⽤ @import
- 尽量⽤缩写、避免⽤滤镜、合理使⽤选择器

### 2.26 CSS3 动画（简单动画的实现，如旋转等）

- 依靠 CSS3 中提出的三个属性： transition 、 transform 、 animation
- transition ：定义了元素在变化过程中是怎么样的，包含 transition-property 、transition-duration 、 transition-timing-function 、 transition-delay 。
- transform ：定义元素的变化结果，包含 rotate 、 scale 、 skew 、 translate 。
- animation ：动画定义了动作的每⼀帧（ @keyframes ）有什么效果，包括 animationname ， animation-duration 、 animation-timing-function 、 animationdelay 、 animation-iteration-count 、 animation-direction

### 2.27 base64 的原理及优缺点

- 优点可以加密，减少了 HTTTP 请求
- 缺点是需要消耗 CPU 进⾏编解码

### 2.28 ⼏种常⻅的 CSS 布局

#### 流体布局

```css
.left {
  float: left;
  width: 100px;
  height: 200px;
  background: red;
}
.right {
  float: right;
  width: 200px;
  height: 200px;
  background: blue;
}
.main {
  margin-left: 120px;
  margin-right: 220px;
  height: 200px;
  background: green;
}
```

```html
<div class="container">
  <div class="left"></div>
  <div class="right"></div>
  <div class="main"></div>
</div>
```

#### 圣杯布局

```css
.container {
  margin-left: 120px;
  margin-right: 220px;
}
.main {
  float: left;
  width: 100%;
  height: 300px;
  background: green;
}
.left {
  position: relative;
  left: -120px;
  float: left;
  height: 300px;
  width: 100px;
  margin-left: -100%;
  background: red;
}
.right {
  position: relative;
  right: -220px;
  float: right;
  height: 300px;
  width: 200px;
  margin-left: -200px;
  background: blue;
}
```

```html
<div class="container">
  <div class="main"></div>
  <div class="left"></div>
  <div class="right"></div>
</div>
```

### 双飞翼布局

```css
.content {
  float: left;
  width: 100%;
}
.main {
  height: 200px;
  margin-left: 110px;
  margin-right: 220px;
  background: green;
}
.main::after {
  content: "";
  display: block;
  font-size: 0;
  height: 0;
  zoom: 1;
  clear: both;
}
.left {
  float: left;
  height: 200px;
  width: 100px;
  margin-left: -100%;
  background: red;
}
.right {
  float: right;
  height: 200px;
  width: 200px;
  margin-left: -200px;
  background: blue;
}
```

```html
<div class="content">
  <div class="main"></div>
</div>
<div class="left"></div>
<div class="right"></div>
```

### 2.29 stylus/sass/less 区别

- 均具有“变量”、“混合”、“嵌套”、“继承”、“颜⾊混合”五⼤基本特性
- Scss 和 LESS 语法较为严谨， LESS 要求⼀定要使⽤⼤括号“{}”， Scss 和 Stylus 可以通过缩进表示层次与嵌套关系
- Scss ⽆全局变量的概念， LESS 和 Stylus 有类似于其它语⾔的作⽤域概念
- Sass 是基于 Ruby 语⾔的，⽽ LESS 和 Stylus 可以基于 NodeJS NPM 下载相应库后进⾏编译

### 2.30 postcss 的作⽤

- 可以直观的理解为：它就是⼀个平台。为什么说它是⼀个平台呢？因为我们直接⽤它，感觉不能⼲什么事情，但是如果让⼀些插件在它上⾯跑，那么将会很强⼤
- PostCSS 提供了⼀个解析器，它能够将 CSS 解析成抽象语法树
- 通过在 PostCSS 这个平台上，我们能够开发⼀些插件，来处理我们的 CSS ，⽐如热⻔的： autoprefixer
- postcss 可以对 sass 处理过后的 css 再处理 最常⻅的就是 autoprefixer

### 2.31 css 样式（选择器）的优先级

- 计算权重确定
- !important
- 内联样式
- 后写的优先级⾼

### 2.32 ⾃定义字体的使⽤场景

- 宣传/品牌/ banner 等固定⽂案
- 字体图标

### 2.33 如何美化 CheckBox

- \<label> 属性 for 和 id
- 隐藏原⽣的 \<input>
- :checked + \<label>

### 2.34 伪类和伪元素的区别

- 伪类表状态
- 伪元素是真的有元素
- 前者单冒号，后者双冒号

### 2.35 base64 的使⽤

- ⽤于减少 HTTP 请求
- 适⽤于⼩图⽚
- base64 的体积约为原图的 4/3

### 2.36 ⾃适应布局

- 左侧浮动或者绝对定位，然后右侧 margin 撑开
- 使⽤ \<div> 包含，然后靠负 margin 形成 bfc
- 使⽤ flex

### 2.37 请⽤ CSS 写⼀个简单的幻灯⽚效果⻚⾯

> 知道是要⽤ CSS3 。使⽤ animation 动画实现⼀个简单的幻灯⽚效果

```css
/**css**/
.ani{
 width:480px;
 height:320px;
 margin:50px auto;
 overflow: hidden;
 box-shadow:0 0 5px rgba(0,0,0,1);
 background-size: cover;
 background-position: center;
 -webkit-animation-name: "loops";
 -webkit-animation-duration: 20s;
 -webkit-animation-iteration-count: infinite;
}
@-webkit-keyframes "loops" {
 0% {
 background:url(http://d.hiphotos.baidu.com/image/w%3D400/sign=c01e6
 }
 25% {
 background:url(http://b.hiphotos.baidu.com/image/w%3D400/sign=edee1
 }
 50% {
 background:url(http://b.hiphotos.baidu.com/image/w%3D400/sign=937da
 }
 75% {
 background:url(http://g.hiphotos.baidu.com/image/w%3D400/sign=7d375
 }
 100% {
 background:url(http://c.hiphotos.baidu.com/image/w%3D400/sign=cfb23
 }
}
```

### 2.38 什么是外边距重叠？重叠的结果是什么

> 外边距重叠就是 margin-collapse

在 CSS 当中，相邻的两个盒⼦（可能是兄弟关系也可能是祖先关系）的外边距可以结合成
⼀个单独的外边距。这种合并外边距的⽅式被称为折叠，并且因⽽所结合成的外边距称为
折叠外边距

折叠结果遵循下列计算规则：

- 两个相邻的外边距都是正数时，折叠结果是它们两者之间较⼤的值。
- 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较⼤值。
- 两个外边距⼀正⼀负时，折叠结果是两者的相加的和。

### 2.39 rgba()和 opacity 的透明效果有什么不同

- rgba() 和 opacity 都能实现透明效果，但最⼤的不同是 opacity 作⽤于元素，以及元素内的所有内容的透明度
- ⽽ rgba() 只作⽤于元素的颜⾊或其背景⾊。（设置 rgba 透明的元素的⼦元素不会继承透明效果！）

### 2.40

## PDF 下载

<https://docs.qq.com/pdf/DV3RpdGR5R2NhbUVI>
