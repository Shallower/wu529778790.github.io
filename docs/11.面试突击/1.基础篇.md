---
title: 基础篇
date: 2022-03-07 14:33:22
permalink: /pages/d4fd303b96708/
categories:
  - 面试突击
tags:
  -
---

【腾讯文档】1、第一部分：基础篇(293 题)

<!-- more -->

## 1. HTML、HTTP、WEB 综合问题

### 1.1 前端需要注意哪些 SEO

- 合理的 title、description、keywords：搜索对这三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过两次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可
- 语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页
- 重要内容 html 代码放在最前：搜索引擎的抓取 HTML 顺序是从上到下，有的时候搜索引擎对抓取长度有限制，保证重要内容一定会被抓取
- 重要内容不要使用 js 输出：爬虫不会执行 js 获取内容
- 少用 iframe：搜索引擎不会抓取 iframe 中的内容
- 非装饰性图片必须加 alt
- 提高网站速度：网站速度是搜索引擎排序的一个重要指标

### 1.2 img 的 title 和 alt 有什么 qubie

- 通常当鼠标滑动到元素上的时候显示
- alt 是 img 特有的属性，是图片显示内容的等价描述，用于图片无法加载时显示。读屏器阅读图片。可提高图片高可访问性，除了纯装饰性图片外都必须设置有意义的值，搜索引擎会重点分析

### 1.3 HTTP 的集中请求方法用途

- GET 方法

发送一个请求来取得服务器的某一资源

- POST 方法

想 URL 指定的资源提交数据或附加新的数据

- PUT 方法

跟 POST 方法很像，也是想服务器提交数据。但是，他们之间有不同。PUT 指定了资源在服务器上的位置，而 post 没有

- HEAD 方法

只请求页面的首部

- DELETE 方法

删除服务器上的某资源

- OPTIONS 方法

它用于获取当前 URL 所支持的方法，如果请求成功，会有一个 ALLOW 的头部包含类似"GET,POST"这样的信息

- TRACE 方法

该方法用于激发一个远程的，应用层的请求消息回路

- CONNECT 方法

把请求连接转换到透明的 TCP/IP 通道

### 1.4 从浏览器地址栏输入 URL 到显示页面的步骤

#### 简略回答

- 浏览器根据请求的 URL 交给 DNS 域名解析，找到真实的 IP，向服务器发送请求
- 服务器交给后台处理完成后返回数据，浏览器接受文件(HTML、JS、CSS、图像等)
- 浏览器对加载到的资源进行语法解析(HTML、JS、CSS、图像等)，建立相应的内部数据结构(如 HTML 的 DOM)
- 载入解析到的资源文件，渲染页面，完成

#### 详细回答

- 在浏览器地址栏输入 URL
- 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤

  1. 如果资源为缓存，发起新请求
  2. 如果已缓存，检查是否新鲜，新鲜则直接提供给客户端，否则与服务器进行验证
  3. 检查是否可用通常有两个 HTTP 头进行控制 Expires 和 Cache-Control

  HTTP1.0 提供 Expires，值为一个绝对时间表示缓存日期

  HTTP1.1 增加了 Cache-Control：max-age=,值为以秒为单位的最大新鲜时间

- 浏览器解析 URL 获取协议，主机，端口，path
- 浏览器组装一个 HTTP 请求报文
- 浏览器获取主机 ip 地址，过程如下：
  1. 浏览器缓存
  2. 本机缓存
  3. hosts 文件
  4. 路由器缓存
  5. ISP DNS 缓存
  6. DNS 递归查询(可能勋在负载均衡导致每次 IP 不一样)
- 打开一个 socket 与目标 ip 地址，端口建立 TCP 链接，三次握手：
  1. 客户端发送一个 TCP 的 SYN=1，Seq=X 的包到服务器端口
  2. 服务器返回 SYN=1，ACK=X+1，Seq=Y 的响应包
  3. 客户端发送 ACK=Y+1，Seq=Z
- TCP 链接建立以后发送 HTTP 请求
- 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用 HTTP Host 头部判断请求的服务程序
- 服务器检查 HTTP 请求头是否包含缓存验证信息，如果验证缓存信息新鲜，返回 304 等对应状态码
- 处理程序读取完整请求并准备 HTTP 响应，可能需要查询数据库等操作
- 服务器将响应报文通过 tcp 链接发送浏览器
- 浏览器接收 HTTP 响应，然后根据情况选择关闭 TCP 连接或者保留重用，关闭 TCP 连接的四次握手如下
  1. 主动方发送 Fin=1,ACK=Z,Seq=X 报文
  2. 被动方发送 ACK=X+1，Seq=Z 报文
  3. 被动方发送 Fin=1，ACK=X，Seq=Y 报文
  4. 主动方发送 ACK=Y，Seq=X 报文
- 浏览器检查响应状态码：是否为 1XX，3XX，4XX，5XX，这些情况处理与 2XX 不同
- 如果资源可缓存，进行缓存
- 对响应进行解码（例如 gzip 压缩）
- 根据资源类型决定如何处理（假设资源类型定位 html 文档）
- 解析 HTML 文档，构建 DOM 树，下载资源，构建 CSSDPOM 树，执行 js 脚本，这些操作没有严格的顺序
- 构建 dom 树

  1. Tokenizing：根据 HTML 规范将字符流解析为标记
  2. Lexing: 词法分析将标记转换为对象并定义属性和规则
  3. DOM construction: 根据 HTML 标记关系并将对象组成 DOM 树

- 解析过程中遇到图片、样式表、JS 文件，启动下载
- 构建 CSSDOM 树：
  1. Tokenizing: 字符流转换成标记流
  2. Node：根据标记创建节点
  3. CSSDOM： 节点创建 CSSOM 树
- 根据 DOM 树和 CSSOM 树构建渲染树
  1. 从 DOM 树的根节点遍历所有可见节点，不可见节点包括 （1）script、meta 这样本身不可见的标签 （2）被 css 隐藏的节点，如 display：none
  2. 对每一个可见节点，找到恰当的 CSSOM 规则并应用
  3. 发布可视节点的内容和计算样式
- js 解析：
  1. 浏览器创建 Document 对象并解析 HTML，将解析到的元素和文本节点添加到文档中，此时 document.readystate 为 loading
  2. HTML 解析器遇到没有 async 和 defer 的 script 时，将他们添加到文档中，然后执行行内或者外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用 document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作 script 和他们之前的文档内容
  3. 当解析器遇到设置了 async 属性的 script 时，开始下载脚本并继续解析文档。脚本会在他下载完成后尽快执行，但是解析器不会停下来等他下载。一步脚本禁止使用 document.write()，他们可以访问自己 script 和之前的文档元素
  4. 当文档完成解析，document.readState 变成 interactive
  5. 所有 defer 脚本会按照在文档中出现的顺序执行，延迟脚本能访问完整文档树，禁止使用 document.write()
  6. 浏览器在 Document 对象上出发 DOMContentLoaded 事件
  7. 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState 变为 complete,window 出发 load 事件
- 显示页面（HTML 解析过程中或逐渐显示页面）

#### 详细简版

1. 从浏览器接受 url 到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）
2. 开启网络线程到发出一个完成的 HTTP 请求(这一部分涉及到 dns 查询，tcp/ip 请求，吴增因特网协议栈等知识)
3. 从服务器接收到请求到对应后台接收到请求(这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等)
4. 后台和前台的 HTTP 交互(这一部分包括 HTTP 头部、响应码、报文结构、cookie 等知识，可以提下静态资源的 cookie 优化，以及编码解码，如 gzip 压缩等)
5. 单独拎出来的缓存问题，HTTP 的缓存(这部分包括 http 缓存头部，Etag，Catch-control 等)
6. 浏览器接收到 HTTP 数据包后的解析流程(解析 html-词法分析然后解析成 dom 树、解析 css 生成 css 规则树、合并成 render 树，然后 layout、painting 渲染、复合涂层的合成、GPU 绘制、外联资源的处理、loaded 和 COMContentLoaded 等)
7. CSS 的可视化格式模型(元素的渲染规则，如包含块，控制狂，BFC，IFC 等概念)
8. JS 引擎解析过程(JS 的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、垃圾回收机制等等)
9. 其他(可以扩展下不同的知识模块，如跨域，web 安全，hybrid 模式等等内容)

### 1.5 如何进行网站性能优化

#### content 方面

- 减少 HTTP 请求：合并文件、css 图片精灵、inline Image
- 减少 DNS 查询：DNS 缓存、将资源分布到恰当数量的主机名
- 减少 DOM 元素数量

#### Server 方面

- 使用 CDN
- 配置 Etag
- 对组件使用 Gzip 压缩

#### Cookie 方法

- 减少 cookie 大小

#### css 方面

- 将样式表放到页面顶部
- 不适用 css 表达式
- 使用 link 不适用 import

#### js 方面

- 将脚本放到页面底部
- 将 js 和 css 从外部引入
- 压缩 js 和 css
- 删除不需要的脚本
- 减少 DOM 访问

#### 图片方面

- 优化图片： 根据实际颜色需要选择色深、压缩
- 优化 css 精灵
- 不要再 html 中拉伸图片

### 1.6 HTTP 状态码以及含义

#### 1XX：信息状态码

- 100 continue 继续，一般在发送 post 请求时，已发送了 http header 之后服务端将返回此信息，表示确认，之后发送具体参数信息

#### 2XX：成功状态码

- 200 OK 正常返回信息
- 201 Created 请求成功并且服务器创建了新的资源
- 202 Accepted 服务器已接收请求，但尚未处理

#### 3XX： 重定向

- 301 Moved Permanently 请求的网页已永久移动到新位置
- 302 Found 临时重定向
- 303 See Other 临时重定向，且总是使用 GET 请求新的 URI
- 304 Not Modified 自从上次请求后，请求的网页未修改过

#### 4XX：客户端错误

- 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求
- 401 Unauthorized 请求未授权
- 403 Forbidden 禁止访问
- 404 Not Found 找不到如何与 URI 相匹配的资源

#### 5XX：服务器错误

- 500 Internal Server Error 最常见的服务器端错误
- 503 Service Unavailabel 服务器端暂时无法处理请求（可能是过载或维护）

### 1.7 语义化的理解

- 用正确的标签做正确的事情
- HTML 语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析
- 在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的
- 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO
- 使阅读源代码的人对网站更容易将网站分块，便于理解维护

### 1.8 浏览器内核

- 主要分成两个部分：渲染引擎(layout engineer 或 Rendering Engine)和 js 引擎
- 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 css 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其他需要编辑、显式网略内容的应用程序都需要内核
- js 引擎规则：解析和执行 js 来实现网页的动态效果
- 最开始渲染引擎和 js 引擎并没有区分的很明显，后来 js 引擎越来越独立，内核就倾向于只指渲染引擎

### 1.9 html5 有哪些新特性、移除了哪些元素？

- HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加
  - 绘画 canvas
  - ⽤于媒介回放的 video 和 audio 元素
  - 本地离线存储 localStorage ⻓期存储数据，浏览器关闭后数据不丢失
  - sessionStorage 的数据在浏览器关闭后⾃动删除
  - 语意化更好的内容元素，⽐如 article 、 footer 、 header 、 nav 、 section
  - 表单控件， calendar 、 date 、 time 、 email 、 url 、 search
  - 新的技术 webworker 、 websocket 、 Geolocation
- 移除的元素：
  - 纯表现的元素： basefont 、 big 、 center 、 font 、 s 、 strike 、 tt 、 u
  - 对可⽤性产⽣负⾯影响的元素： frame 、 frameset 、 noframes
- ⽀持 HTML5 新标签：
  - IE8/IE7/IE6 ⽀持通过 document.createElement ⽅法产⽣的标签
  - 可以利⽤这⼀特性让这些浏览器⽀持 HTML5 新标签
  - 浏览器⽀持新标签后，还需要添加标签默认的样式
- 当然也可以直接使⽤成熟的框架、⽐如 html5shim

### 1.10 HTML5 的离线储存怎么使⽤，⼯作原理能不能解释⼀下

- 在⽤户没有与因特⽹连接时，可以正常访问站点或应⽤，在⽤户与因特⽹连接时，更新⽤户机器上的缓存⽂件
- 原理： HTML5 的离线存储是基于⼀个新建的 .appcache ⽂件的缓存机制(不是存储技术)，通过这个⽂件上的解析清单离线存储资源，这些资源就会像 cookie ⼀样被存储了下来。之后当⽹络在处于离线状态下时，浏览器会通过被离线存储的数据进⾏⻚⾯展示
- 如何使⽤：
  - ⻚⾯头部像下⾯⼀样加⼊⼀个 manifest 的属性；
  - 在 cache.manifest ⽂件的编写离线存储的资源
  - 在离线状态时，操作 window.applicationCache 进⾏需求实现

### 1.11 浏览器是怎么对 HTML5 的离线储存资源进⾏管理和加载的呢

- 在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest ⽂件，如果是第⼀次访问 app ，那么浏览器就会根据 manifest ⽂件的内容下载相应的资源并且进⾏离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使⽤离线的资源加载⻚⾯，然后浏览器会对⽐新的 manifest ⽂件与旧的 manifest ⽂件，如果⽂件没有发⽣改变，就不做任何操作，如果⽂件改变了，那么就会重新下载⽂件中的资源并进⾏离线存储
- 离线的情况下，浏览器就直接使⽤离线存储的资源

### 请描述⼀下 cookies ， sessionStorage 和 localStorage 的区别

- cookie 是⽹站为了标示⽤户身份⽽储存在⽤户本地终端（Client Side）上的数据（通常经过加密）
- cookie 数据始终在同源的 http 请求中携带（即使不需要），记会在浏览器和服务器间来回传递
- sessionStorage 和 localStorage 不会⾃动把数据发给服务器，仅在本地保存
- 存储⼤⼩：
  - cookie 数据⼤⼩不能超过 4k
  - sessionStorage 和 localStorage 虽然也有存储⼤⼩的限制，但⽐ cookie ⼤得多，可以达到 5M 或更⼤
- 有期时间：
  - localStorage 存储持久数据，浏览器关闭后数据不丢失除⾮主动删除数据
  - sessionStorage 数据在当前浏览器窗⼝关闭后⾃动删除
  - cookie 设置的 cookie 过期时间之前⼀直有效，即使窗⼝或浏览器关闭

### 1.13 iframe 有那些缺点

- iframe 会阻塞主⻚⾯的 Onload 事件
- 搜索引擎的检索程序⽆法解读这种⻚⾯，不利于 SEO
- iframe 和主⻚⾯共享连接池，⽽浏览器对相同域的连接有限制，所以会影响⻚⾯的并⾏加载
- 使⽤ iframe 之前需要考虑这两个缺点。如果需要使⽤ iframe ，最好是通过 javascript 动态给 iframe 添加 src 属性值，这样可以绕开以上两个问题

### 1.14 WEB 标准以及 W3C 标准是什么

- 标签闭合、标签⼩写、不乱嵌套、使⽤外链 css 和 js 、结构⾏为表现的分离

### 1.15 xhtml 和 html 有什么区别

- xhtml 和 html 有什么区别
  - 主要是 XHTML 可兼容各⼤浏览器、⼿机以及 PDA ，并且浏览器也能快速正确地编译⽹⻚
- 另外是书写习惯的差别
  - XHTML 元素必须被正确地嵌套，闭合，区分⼤⼩写，⽂档必须拥有根元素

### 1.16 Doctype 作⽤? 严格模式与混杂模式如何区分？它们有何意义

- ⻚⾯被加载的时， link 会同时被加载，⽽ @imort ⻚⾯被加载的时， link 会同时被加载，⽽ @import 引⽤的 CSS 会等到⻚⾯被加载完再加载 import 只在 IE5 以上才能识别，⽽ link 是 XHTML 标签，⽆兼容问题 link ⽅式的样式的权重 ⾼于 @import 的权重
- \<!DOCTYPE\> 声明位于⽂档中的最前⾯，处于 \<html\> 标签之前。告知浏览器的解析器， ⽤什么⽂档类型 规范来解析这个⽂档
- 严格模式的排版和 JS 运作模式是 以该浏览器⽀持的最⾼标准运⾏
- 在混杂模式中，⻚⾯以宽松的向后兼容的⽅式显示。模拟⽼式浏览器的⾏为以防⽌站点⽆法⼯作。 DOCTYPE 不存在或格式不正确会导致⽂档以混杂模式呈现

### 1.17 ⾏内元素有哪些？块级元素有哪些？ 空(void)元素有那些？⾏内元素和块级元素有什么区别

- ⾏内元素有： a b span img input select strong
- 块级元素有： div ul ol li dl dt dd h1 h2 h3 h4… p
- 空元素： \<br> \<hr> \<img> \<input> \<link> \<meta>
- ⾏内元素不可以设置宽⾼，不独占⼀⾏
- 块级元素可以设置宽⾼，独占⼀⾏

### 1.18 HTML 全局属性(global attribute)有哪些

- class :为元素设置类标识
- data-\* : 为元素增加⾃定义属性
- draggable : 设置元素是否可拖拽
- id : 元素 id ，⽂档内唯⼀
- lang : 元素内容的的语⾔
- style : ⾏内 css 样式
- title : 元素相关的建议信息

### 1.19 Canvas 和 SVG 有什么区别？

- svg 绘制出来的每⼀个图形的元素都是独⽴的 DOM 节点，能够⽅便的绑定事件或⽤来修改。 canvas 输出的是⼀整幅画布
- svg 输出的图形是⽮量图形，后期可以修改参数来⾃由放⼤缩⼩，不会失真和锯⻮。⽽ canvas 输出标量画布，就像⼀张图⽚⼀样，放⼤会失真或者锯⻮

### 1.20 HTML5 为什么只需要写 \<!DOCTYPE HTML\>

- HTML5 不基于 SGML ，因此不需要对 DTD 进⾏引⽤，但是需要 doctype 来规范浏览器的⾏为
- ⽽ HTML4.01 基于 SGML ,所以需要对 DTD 进⾏引⽤，才能告知浏览器⽂档所使⽤的⽂档类型

### 1.21 如何在⻚⾯上实现⼀个圆形的可点击区域？

- svg
- border-radius
- 纯 js 实现 需要求⼀个点在不在圆上简单算法、获取⿏标坐标等等

### 1.22 ⽹⻚验证码是⼲嘛的，是为了解决什么安全问题

- 区分⽤户是计算机还是⼈的公共全⾃动程序。可以防⽌恶意破解密码、刷票、论坛灌⽔
- 有效防⽌⿊客对某⼀个特定注册⽤户⽤特定程序暴⼒破解⽅式进⾏不断的登陆尝试

### 1.23 viewport

```html
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<!-- width 设置viewport宽度，为⼀个正整数，或字符串‘device-width’
 device-width 设备宽度
 height 设置viewport⾼度，⼀般设置了宽度，会⾃动解析出⾼度，可以不⽤设置
 initial-scale 默认缩放⽐例（初始缩放⽐例），为⼀个数字，可以带⼩数
 minimum-scale 允许⽤户最⼩缩放⽐例，为⼀个数字，可以带⼩数
 maximum-scale 允许⽤户最⼤缩放⽐例，为⼀个数字，可以带⼩数
 user-scalable 是否允许⼿动缩放 -->
```

> 怎样处理 移动端 1px 被 渲染成 2px 问题

- 局部处理
  - mate 标签中的 viewport 属性 ， initial-scale 设置为 1
  - rem 按照设计稿标准⾛，外加利⽤ transfrome 的 scale(0.5) 缩⼩⼀倍即可；
- 全局处理
  - mate 标签中的 viewport 属性 ， initial-scale 设置为 0.5
  - rem 按照设计稿标准⾛即可

### 1.24 渲染优化

- 禁⽌使⽤ iframe （阻塞⽗⽂档 onload 事件）
  - iframe 会阻塞主⻚⾯的 Onload 事件
  - 搜索引擎的检索程序⽆法解读这种⻚⾯，不利于 SEO
  - iframe 和主⻚⾯共享连接池，⽽浏览器对相同域的连接有限制，所以会影响⻚⾯的并⾏加载
  - 使⽤ iframe 之前需要考虑这两个缺点。如果需要使⽤ iframe ，最好是通过 javascript 动态给 iframe 添加 src 属性值，这样可以绕开以上两个问题
- 禁⽌使⽤ gif 图⽚实现 loading 效果（降低 CPU 消耗，提升渲染性能）
- 使⽤ CSS3 代码代替 JS 动画（尽可能避免重绘重排以及回流）
- 对于⼀些⼩图标，可以使⽤ base64 位编码，以减少⽹络请求。但不建议⼤图使⽤，⽐较耗费 CPU
  - ⼩图标优势在于
    - 减少 HTTP 请求
    - 避免⽂件跨域
    - 修改及时⽣效
- ⻚⾯头部的 \<style></style> \<script></script> 会阻塞⻚⾯；（因为 Renderer 进程中 JS 线程和渲染线程是互斥的）
- ⻚⾯中空的 href 和 src 会阻塞⻚⾯其他资源的加载 (阻塞下载进程)
- ⽹⻚ gzip ， CDN 托管， data 缓存 ，图⽚服务器
- 前端模板 JS+数据，减少由于 HTML 标签导致的带宽浪费，前端⽤变量保存 AJAX 请求结果，每次操作本地变量，不⽤请求，减少请求次数
- ⽤ innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能
- 当需要设置的样式很多时设置 className ⽽不是直接操作 style 少⽤全局变量、缓存 DOM 节点查找的结果。减少 IO 读取操作
- 图⽚预加载，将样式表放在顶部，将脚本放在底部 加上时间戳
- 对普通的⽹站有⼀个统⼀的思路，就是尽量向前端优化、减少数据库操作、减少磁盘 IO

### 1.25 meta viewport 相关

```html
<!DOCTYPE html>
<!--H5标准声明，使⽤ HTML5 doctype，不区分⼤⼩写-->
<head lang="”en”">
  <!--标准的 lang 属性写法-->
  <meta charset="’utf-8′" />
  <!--声明⽂档使⽤的字符编码-->
  <meta http-equiv="”X-UA-Compatible”" content="”IE" ="edge,chrome" ="1″" />
  <!--优先使
<meta name=”description” content=”不超过150个字符”/> <!--⻚⾯描述-->
  <meta name="”keywords”" content="””" />
  <!-- ⻚⾯关键词-->
  <meta name="”author”" content="”name," email@gmail.com” />
  <!--⽹⻚作者-->
  <meta name="”robots”" content="”index,follow”" />
  <!--搜索引擎抓取-->
  <meta
    name="”viewport”"
    content="”initial-scale"
    ="1,"
    maximum-scale="3,"
    minimum-sc
    <meta
    name="”apple-mobile-web-app-title”"
    content="”标题”"
  />
  <!--iOS 设备 begin-->
  <meta name="”apple-mobile-web-app-capable”" content="”yes”" />
  <!--添加到主屏后的标
是否启⽤ WebApp 全屏模式，删除苹果默认的⼯具栏和菜单栏-->
  <meta
    name="”apple-itunes-app”"
    content="”app-id"
    ="myAppStoreID,"
    affiliate-data="<!--添加智能"
    App
    ⼴告条
    Smart
    App
    Banner（iOS
    6+
    Safari）--
  />
  <meta name="”apple-mobile-web-app-status-bar-style”" content="”black”" />
  <meta name="”format-detection”" content="”telphone" ="no," email="no”" />
  <!--设置苹果
<meta name=”renderer” content=”webkit”> <!-- 启⽤360浏览器的极速模式(webkit)-->
  <meta http-equiv="”X-UA-Compatible”" content="”IE" ="edge”" />
  <!--避免IE使⽤兼容模
<meta http-equiv=”Cache-Control” content=”no-siteapp” /> <!--不让百度转码-
<meta name=”HandheldFriendly” content=”true”> <!--针对⼿持设备优化，主要是针
<meta name=”MobileOptimized” content=”320″> <!--微软的⽼式浏览器-->
  <meta name="”screen-orientation”" content="”portrait”" />
  <!--uc强制竖屏-->
  <meta name="”x5-orientation”" content="”portrait”" />
  <!--QQ强制竖屏-->
  <meta name="”full-screen”" content="”yes”" />
  <!--UC强制全屏-->
  <meta name="”x5-fullscreen”" content="”true”" />
  <!--QQ强制全屏-->
  <meta name="”browsermode”" content="”application”" />
  <!--UC应⽤模式-->
  <meta name="”x5-page-mode”" content="”app”" />
  <!-- QQ应⽤模式-->
  <meta name="”msapplication-tap-highlight”" content="”no”" />
  <!--windows phone 设置⻚⾯不缓存-->
  <meta http-equiv="”pragma”" content="”no-cache”" />
  <meta http-equiv="”cache-control”" content="”no-cache”" />
  <meta http-equiv="”expires”" content="”0″" />
</head>
```

### 1.26 你做的⻚⾯在哪些流览器测试过？这些浏览器的内核分别是什么

- IE : trident 内核
- Firefox ： gecko 内核
- Safari : webkit 内核
- Opera :以前是 presto 内核， Opera 现已改⽤ Google - Chrome 的 Blink 内核
- Chrome:Blink (基于 webkit ，Google 与 Opera Software 共同开发)

### 1.27 div+css 的布局较 table 布局有什么优点

- 改版的时候更⽅便 只要改 css ⽂件。
- ⻚⾯加载速度更快、结构化清晰、⻚⾯显示简洁。
- 表现与结构相分离。
- 易于优化（ seo ）搜索引擎更友好，排名更容易靠前。

### 1.28 a：img 的 alt 与 title 有何异同？b：strong 与 em 的异同

- alt(alt text) :为不能显示图像、窗体或 applets 的⽤户代理（ UA ）， alt 属性⽤来指定替换⽂字。替换⽂字的语⾔由 lang 属性指定。(在 IE 浏览器下会在没有 title 时把 alt 当成 tool tip 显示)
- title(tool tip) :该属性为设置该属性的元素提供建议性的信息
- strong :粗体强调标签，强调，表示内容的重要性
- em :斜体强调标签，更强烈强调，表示内容的强调点

### 1.29 你能描述⼀下渐进增强和优雅降级之间的不同吗

- 渐进增强：针对低版本浏览器进⾏构建⻚⾯，保证最基本的功能，然后再针对⾼级浏览器进⾏效果、交互等改进和追加功能达到更好的⽤户体验。
- 优雅降级：⼀开始就构建完整的功能，然后再针对低版本浏览器进⾏兼容。

> 区别：优雅降级是从复杂的现状开始，并试图减少⽤户体验的供给，⽽渐进增强则是从⼀个⾮常基础的，能够起作⽤的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；⽽渐进增强则意味着朝前看，同时保证其根基处于安全地带

### 1.30 为什么利⽤多个域名来存储⽹站资源会更有效

- CDN 缓存更⽅便
- 突破浏览器并发限制
- 节约 cookie 带宽
- 节约主域名的连接数，优化⻚⾯响应速度
- 防⽌不必要的安全问题

### 1.31 简述⼀下 src 与 href 的区别

- src ⽤于替换当前元素，href ⽤于在当前⽂档和引⽤资源之间确⽴联系。
- src 是 source 的缩写，指向外部资源的位置，指向的内容将会嵌⼊到⽂档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应⽤到⽂档内，例如 js 脚本，img 图⽚和 frame 等元素

> \<script src ="js.js"></script> 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，图⽚和框架等元素也如此，类似于将所指向资源嵌⼊当前标签内。这也是为什么将 js 脚本放在底部⽽不是头部

- href 是 Hypertext Reference 的缩写，指向⽹络资源所在位置，建⽴和当前元素（锚点）或当前⽂档（链接）之间的链接，如果我们在⽂档中添加
  \<link href="common.css" rel="stylesheet"/> 那么浏览器会识别该⽂档为 css ⽂件，就会并⾏下载资源并且不会停⽌对当前⽂档的处理。这也是为什么建议使⽤ link ⽅式来加载 css ，⽽不是使⽤ @import ⽅式

### 1.32 知道的⽹⻚制作会⽤到的图⽚格式有哪些

- png-8 、 png-24 、 jpeg 、 gif 、 svg

> 但是上⾯的那些都不是⾯试官想要的最后答案。⾯试官希望听到是 Webp , Apng 。（是否有关注新技术，新鲜事物）

- Webp： WebP 格式，⾕歌（google）开发的⼀种旨在加快图⽚加载速度的图⽚格式。图⽚压缩体积⼤约只有 JPEG 的 2/3 ，并能节省⼤量的服务器带宽资源和数据空间。Facebook Ebay 等知名⽹站已经开始测试并使⽤ WebP 格式。
- 在质量相同的情况下，WebP 格式图像的体积要⽐ JPEG 格式图像⼩ 40% 。
- Apng：全称是 “Animated Portable Network Graphics” , 是 PNG 的位图动画扩展，可以实现 png 格式的动态图⽚效果。04 年诞⽣，但⼀直得不到各⼤浏览器⼚商的⽀持，直到⽇前得到 iOS safari 8 的⽀持，有望代替 GIF 成为下⼀代动态图标准

### 1.32 在 css/js 代码上线之后开发⼈员经常会优化性能，从⽤户刷新⽹⻚开始，⼀次 js 请求⼀般情况下有哪些地⽅会有缓存处理

> dns 缓存， cdn 缓存，浏览器缓存，服务器缓存

### 1.33 ⼀个⻚⾯上有⼤量的图⽚（⼤型电商⽹站），加载很慢，你有哪些⽅法优化这些图⽚的加载，给⽤户更好的体验

- 图⽚懒加载，在⻚⾯上的未可视区域可以添加⼀个滚动事件，判断图⽚位置与浏览器顶端的距离与⻚⾯的距离，如果前者⼩于后者，优先加载。
- 如果为幻灯⽚、相册等，可以使⽤图⽚预加载技术，将当前展示图⽚的前⼀张和后⼀张优先下载。
- 如果图⽚为 css 图⽚，可以使⽤ CSSsprite ， SVGsprite ， Iconfont 、 Base64 等技术。
- 如果图⽚过⼤，可以使⽤特殊编码的图⽚，加载时会先加载⼀张压缩的特别厉害的缩略图，以提⾼⽤户体验。
- 如果图⽚展示区域⼩于图⽚的真实⼤⼩，则因在服务器端根据业务需要先⾏进⾏图⽚压缩，图⽚压缩后⼤⼩与展示⼀致

### 1.34 常⻅排序算法的时间复杂度,空间复杂度

![46147c7c921641a691daa9fcb69661fd](https://cdn.jsdelivr.net/gh/wu529778790/image/blog/46147c7c921641a691daa9fcb69661fd.png)

### 1.35 web 开发中会话跟踪的⽅法有哪些

- cookie
- session
- url 重写
- 隐藏 input
- ip 地址

### 1.36 HTTP request 报⽂结构是怎样的

1. ⾸⾏是 Request-Line 包括：请求⽅法，请求 URI，协议版本，CRLF
2. ⾸⾏之后是若⼲⾏请求头，包括 general-header，request-header 或者 entity-header，每个⼀⾏以 CRLF 结束
3. 请求头和消息实体之间有⼀个 CRLF 分隔
4. 根据实际请求需要可能包含⼀个消息实体 ⼀个请求报⽂例⼦如下：

```json
GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1
Host: www.w3.org
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML,
Referer: https://www.google.com.hk/
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6
Cookie: authorstyle=yes
If-None-Match: "2cc8-3e3073913b100"
If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT
name=qiu&age=25
```

### 1.37 HTTP response 报⽂结构是怎样的

- ⾸⾏是状态⾏包括：HTTP 版本，状态码，状态描述，后⾯跟⼀个 CRLF
- ⾸⾏之后是若⼲⾏响应头，包括：通⽤头部，响应头部，实体头部
- 响应头部和响应实体之间⽤⼀个 CRLF 空⾏分隔
- 最后是⼀个可能的消息实体 响应报⽂例⼦如下：

```json
HTTP/1.1 200 OK
Date: Tue, 08 Jul 2014 05:28:43 GMT
Server: Apache/2
Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT
ETag: "40d7-3e3073913b100"
Accept-Ranges: bytes
Content-Length: 16599
Cache-Control: max-age=21600
Expires: Tue, 08 Jul 2014 11:28:43 GMT
P3P: policyref="http://www.w3.org/2001/05/P3P/p3p.xml"
Content-Type: text/html; charset=iso-8859-1
{"name": "qiu", "age": 25}
```

## 2. CSS

### 2.1 css sprite 是什么,有什么优缺点

- 概念：将多个⼩图⽚拼接到⼀个图⽚中。通过 background-position 和元素尺⼨调节需要显示的背景图案。
- 优点：
  - 减少 HTTP 请求数，极⼤地提⾼⻚⾯加载速度
  - 增加图⽚信息重复度，提⾼压缩⽐，减少图⽚⼤⼩
  - 更换⻛格⽅便，只需在⼀张或⼏张图⽚上修改颜⾊或样式即可实现
- 缺点：
  - 图⽚合并麻烦
  - 维护麻烦，修改⼀个图⽚可能需要从新布局整个图⽚，样式

### 2.2 display: none; 与 visibility: hidden; 的区别

- 联系：它们都能让元素不可⻅
- 区别：
  - display:none ;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden ;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可⻅
  - display: none ;是⾮继承属性，⼦孙节点消失由于元素从渲染树消失造成，通过修改⼦孙节点属性⽆法显示 ；visibility: hidden; 是继承属性，⼦孙节点消失由于继承了 hidden ，通过设置 visibility: visible; 可以让⼦孙节点显式
  - 修改常规流中元素的 display 通常会造成⽂档重排。修改 visibility 属性只会造成本元素的重绘。
  - 读屏器不会读取 display: none ;元素内容；会读取 visibility: hidden; 元素内容

### 2.3 link 与 @import 的区别

1. link 是 HTML ⽅式， @import 是 CSS ⽅式
2. link 最⼤限度⽀持并⾏下载， @import 过多嵌套导致串⾏下载，出现 FOUC (⽂档样式短暂失效)
3. link 可以通过 rel="alternate stylesheet" 指定候选样式
4. 浏览器对 link ⽀持早于 @import ，可以使⽤ @import 对⽼浏览器隐藏样式
5. @import 必须在样式规则之前，可以在 css ⽂件中引⽤其他⽂件
6. 总体来说： link 优于 @import

### 2.4 什么是 FOUC?如何避免

- Flash Of Unstyled Content ：⽤户定义样式表加载之前浏览器使⽤默认样式显示⽂档，⽤户样式加载渲染之后再从新显示⽂档，造成⻚⾯闪烁。
- 解决⽅法：把样式表放到⽂档的 \<head>

### 2.5 如何创建块级格式化上下⽂(block formatting context),BFC 有什么⽤

- 创建规则：
  - 根元素
  - 浮动元素（ float 不取值为 none ）
  - 绝对定位元素（ position 取值为 absolute 或 fixed ）
  - display 取值为 inline-block 、 table-cell 、 table-caption 、 flex 、
  - inline-flex 之⼀的元素
  - overflow 不取值为 visible 的元素
- 作用
  - 可以包含浮动元素
  - 不被浮动元素覆盖
  - 阻⽌⽗⼦元素的 margin 折叠

### 2.6 display、float、position 的关系

- 如果 display 取值为 none ，那么 position 和 float 都不起作⽤，这种情况下元素不产⽣框
- 否则，如果 position 取值为 absolute 或者 fixed ，框就是绝对定位的， float 的计算值为 none ， display 根据下⾯的表格进⾏调整。
- 否则，如果 float 不是 none ，框是浮动的， display 根据下表进⾏调整
- 否则，如果元素是根元素， display 根据下表进⾏调整
- 其他情况下 display 的值为指定值
- 总结起来：绝对定位、浮动、根元素都需要调整 display

### 2.7 清除浮动的⼏种⽅式，各⾃的优缺点

- ⽗级 div 定义 height
- 结尾处加空 div 标签 clear:both
- ⽗级 div 定义伪类 :after 和 zoom
- ⽗级 div 定义 overflow:hidden
- ⽗级 div 也浮动，需要定义宽度
- 结尾处加 br 标签 clear:both

> ⽐较好的是第 3 种⽅式，好多⽹站都这么⽤

### 2.8 为什么要初始化 CSS 样式

- 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对 CSS 初始化往往会出现浏览器之间的⻚⾯显示差异。
- 当然，初始化样式会对 SEO 有⼀定的影响，但⻥和熊掌不可兼得，但⼒求影响最⼩的情况下初始化

### 2.9 css3 有哪些新特性

- 新增各种 css 选择器
- 圆⻆ border-radius
- 多列布局
- 阴影和反射
- ⽂字特效 text-shadow
- 线性渐变
- 旋转 transform

#### CSS3 新增伪类有那些？

- p:first-of-type 选择属于其⽗元素的⾸个 \<p> 元素的每个 \<p> 元素。
- p:last-of-type 选择属于其⽗元素的最后 \<p> 元素的每个 \<p> 元素。
- p:only-of-type 选择属于其⽗元素唯⼀的 \<p> 元素的每个 \<p> 元素。
- p:only-child 选择属于其⽗元素的唯⼀⼦元素的每个 \<p> 元素。
- p:nth-child(2) 选择属于其⽗元素的第⼆个⼦元素的每个 \<p> 元素。
- :after 在元素之前添加内容,也可以⽤来做清除浮动。
- :before 在元素之后添加内容。
- :enabled 已启⽤的表单元素。
- :disabled 已禁⽤的表单元素。
- :checked 单选框或复选框被选中

### 2.10 display 有哪些值？说明他们的作⽤

- block 转换成块状元素。
- inline 转换成⾏内元素。
- none 设置元素不可⻅。
- inline-block 象⾏内元素⼀样显示，但其内容象块类型元素⼀样显示。
- list-item 象块类型元素⼀样显示，并添加样式列表标记。
- table 此元素会作为块级表格来显示
- inherit 规定应该从⽗元素继承 display 属性的值

### 2.11 介绍⼀下标准的 CSS 的盒⼦模型？低版本 IE 的盒⼦模型有什么不同的

- 有两种， IE 盒⼦模型、 W3C 盒⼦模型；
- 盒模型： 内容(content)、填充( padding )、边界( margin )、 边框( border )；
- 区 别： IE 的 c ontent 部分把 border 和 padding 计算了进去

### 2.12 CSS 优先级算法如何计算？

- 优先级就近原则，同权重情况下样式定义最近者为准
- 载⼊样式以最后载⼊的定位为准
- 优先级为: !important > id > class > tag ; !important ⽐ 内联优先级⾼

### 2.13 对 BFC 规范的理解？

- 它决定了元素如何对其内容进⾏定位,以及与其他元素的关系和相互作⽤

### 2.14 谈谈浮动和清除浮动

- 浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另⼀个浮动框的边框为⽌。由于浮动框不在⽂档的普通流中，所以⽂档的普通流的块框表现得就像浮动框不存在⼀样。浮动的块框会漂浮在⽂档普通流的块框上

### 2.15 position 的值， relative 和 absolute 定位原点是

- absolute ：⽣成绝对定位的元素，相对于 static 定位以外的第⼀个⽗元素进⾏定位
- fixed ：⽣成绝对定位的元素，相对于浏览器窗⼝进⾏定位
- relative ：⽣成相对定位的元素，相对于其正常位置进⾏定位
- static 默认值。没有定位，元素出现在正常的流中
- inherit 规定从⽗元素继承 position 属性的值

### 2.16 display:inline-block 什么时候不会显示间隙？(携程)

- 移除空格
- 使⽤ margin 负值
- 使⽤ font-size:0
- letter-spacing
- word-spacing

### 2.17 PNG\GIF\JPG 的区别及如何选

- GIF
  - 8 位像素， 256 ⾊
  - ⽆损压缩
  - ⽀持简单动画
  - ⽀持 boolean 透明
  - 适合简单动画
- JPEG
  - 颜⾊限于 256
  - 有损压缩
  - 可控制压缩质量
  - 不⽀持透明
  - 适合照⽚
- PNG
  - 有 PNG8 和 truecolor PNG
  - PNG8 类似 GIF 颜⾊上限为 256 ，⽂件⼩，⽀持 alpha 透明度，⽆动画
  - 适合图标、背景、按钮

### 2.18 ⾏内元素 float:left 后是否变为块级元素？

> ⾏内元素设置成浮动之后变得更加像是 inline-block （⾏内块级元素，设置成这个属性的元素会同时拥有⾏内和块级的特性，最明显的不同是它的默认宽度不是 100% ），这时候给⾏内元素设置 padding-top 和 padding-bottom 或者 width 、 height 都是有效果的

### 2.19 在⽹⻚中的应该使⽤奇数还是偶数的字体？为什么呢？

- 偶数字号相对更容易和 web 设计的其他部分构成⽐例关系

### 2.20 ::before 和 :after 中双冒号和单冒号 有什么区别？解释⼀下这 2 个伪元素的作⽤

- 单冒号( : )⽤于 CSS3 伪类，双冒号( :: )⽤于 CSS3 伪元素
- ⽤于区分伪类和伪元素

### 2.21 如果需要⼿动写动画，你认为最⼩时间间隔是多久，为什么？（阿⾥）

- 多数显示器默认频率是 60Hz ，即 1 秒刷新 60 次，所以理论上最⼩间隔为 `1/60*1000ms ＝ 16.7ms`

### 2.22 CSS 合并⽅法

- 避免使⽤ @import 引⼊多个 css ⽂件，可以使⽤ CSS ⼯具将 CSS 合并为⼀个 CSS ⽂件，例如使⽤ Sass\Compass 等

### 2.23 CSS 不同选择器的权重(CSS 层叠的规则)

- ！important 规则最重要，⼤于其它规则
- ⾏内样式规则，加 1000
- 对于选择器中给定的各个 ID 属性值，加 100
- 对于选择器中给定的各个类属性、属性选择器或者伪类选择器，加 10
- 对于选择其中给定的各个元素标签选择器，加 1
- 如果权值⼀样，则按照样式规则的先后顺序来应⽤，顺序靠后的覆盖靠前的规则

### 2.24 列出你所知道可以改变⻚⾯布局的属性

- position 、 display 、 float 、 width 、 height 、 margin 、 padding 、top 、 left 、 right

### 2.25 CSS 在性能优化⽅⾯的实践

- css 压缩与合并、 Gzip 压缩
- css ⽂件放在 head ⾥、不要⽤ @import
- 尽量⽤缩写、避免⽤滤镜、合理使⽤选择器

### 2.26 CSS3 动画（简单动画的实现，如旋转等）

- 依靠 CSS3 中提出的三个属性： transition 、 transform 、 animation
- transition ：定义了元素在变化过程中是怎么样的，包含 transition-property 、transition-duration 、 transition-timing-function 、 transition-delay 。
- transform ：定义元素的变化结果，包含 rotate 、 scale 、 skew 、 translate 。
- animation ：动画定义了动作的每⼀帧（ @keyframes ）有什么效果，包括 animationname ， animation-duration 、 animation-timing-function 、 animationdelay 、 animation-iteration-count 、 animation-direction

### 2.27 base64 的原理及优缺点

- 优点可以加密，减少了 HTTTP 请求
- 缺点是需要消耗 CPU 进⾏编解码

### 2.28 ⼏种常⻅的 CSS 布局

#### 流体布局

```css
.left {
  float: left;
  width: 100px;
  height: 200px;
  background: red;
}
.right {
  float: right;
  width: 200px;
  height: 200px;
  background: blue;
}
.main {
  margin-left: 120px;
  margin-right: 220px;
  height: 200px;
  background: green;
}
```

```html
<div class="container">
  <div class="left"></div>
  <div class="right"></div>
  <div class="main"></div>
</div>
```

#### 圣杯布局

```css
.container {
  margin-left: 120px;
  margin-right: 220px;
}
.main {
  float: left;
  width: 100%;
  height: 300px;
  background: green;
}
.left {
  position: relative;
  left: -120px;
  float: left;
  height: 300px;
  width: 100px;
  margin-left: -100%;
  background: red;
}
.right {
  position: relative;
  right: -220px;
  float: right;
  height: 300px;
  width: 200px;
  margin-left: -200px;
  background: blue;
}
```

```html
<div class="container">
  <div class="main"></div>
  <div class="left"></div>
  <div class="right"></div>
</div>
```

### 双飞翼布局

```css
.content {
  float: left;
  width: 100%;
}
.main {
  height: 200px;
  margin-left: 110px;
  margin-right: 220px;
  background: green;
}
.main::after {
  content: "";
  display: block;
  font-size: 0;
  height: 0;
  zoom: 1;
  clear: both;
}
.left {
  float: left;
  height: 200px;
  width: 100px;
  margin-left: -100%;
  background: red;
}
.right {
  float: right;
  height: 200px;
  width: 200px;
  margin-left: -200px;
  background: blue;
}
```

```html
<div class="content">
  <div class="main"></div>
</div>
<div class="left"></div>
<div class="right"></div>
```

### 2.29 stylus/sass/less 区别

- 均具有“变量”、“混合”、“嵌套”、“继承”、“颜⾊混合”五⼤基本特性
- Scss 和 LESS 语法较为严谨， LESS 要求⼀定要使⽤⼤括号“{}”， Scss 和 Stylus 可以通过缩进表示层次与嵌套关系
- Scss ⽆全局变量的概念， LESS 和 Stylus 有类似于其它语⾔的作⽤域概念
- Sass 是基于 Ruby 语⾔的，⽽ LESS 和 Stylus 可以基于 NodeJS NPM 下载相应库后进⾏编译

### 2.30 postcss 的作⽤

- 可以直观的理解为：它就是⼀个平台。为什么说它是⼀个平台呢？因为我们直接⽤它，感觉不能⼲什么事情，但是如果让⼀些插件在它上⾯跑，那么将会很强⼤
- PostCSS 提供了⼀个解析器，它能够将 CSS 解析成抽象语法树
- 通过在 PostCSS 这个平台上，我们能够开发⼀些插件，来处理我们的 CSS ，⽐如热⻔的： autoprefixer
- postcss 可以对 sass 处理过后的 css 再处理 最常⻅的就是 autoprefixer

### 2.31 css 样式（选择器）的优先级

- 计算权重确定
- !important
- 内联样式
- 后写的优先级⾼

### 2.32 ⾃定义字体的使⽤场景

- 宣传/品牌/ banner 等固定⽂案
- 字体图标

### 2.33 如何美化 CheckBox

- \<label> 属性 for 和 id
- 隐藏原⽣的 \<input>
- :checked + \<label>

### 2.34 伪类和伪元素的区别

- 伪类表状态
- 伪元素是真的有元素
- 前者单冒号，后者双冒号

### 2.35 base64 的使⽤

- ⽤于减少 HTTP 请求
- 适⽤于⼩图⽚
- base64 的体积约为原图的 4/3

### 2.36 ⾃适应布局

- 左侧浮动或者绝对定位，然后右侧 margin 撑开
- 使⽤ \<div> 包含，然后靠负 margin 形成 bfc
- 使⽤ flex

### 2.37 请⽤ CSS 写⼀个简单的幻灯⽚效果⻚⾯

> 知道是要⽤ CSS3 。使⽤ animation 动画实现⼀个简单的幻灯⽚效果

```css
/**css**/
.ani{
 width:480px;
 height:320px;
 margin:50px auto;
 overflow: hidden;
 box-shadow:0 0 5px rgba(0,0,0,1);
 background-size: cover;
 background-position: center;
 -webkit-animation-name: "loops";
 -webkit-animation-duration: 20s;
 -webkit-animation-iteration-count: infinite;
}
@-webkit-keyframes "loops" {
 0% {
 background:url(http://d.hiphotos.baidu.com/image/w%3D400/sign=c01e6
 }
 25% {
 background:url(http://b.hiphotos.baidu.com/image/w%3D400/sign=edee1
 }
 50% {
 background:url(http://b.hiphotos.baidu.com/image/w%3D400/sign=937da
 }
 75% {
 background:url(http://g.hiphotos.baidu.com/image/w%3D400/sign=7d375
 }
 100% {
 background:url(http://c.hiphotos.baidu.com/image/w%3D400/sign=cfb23
 }
}
```

### 2.38 什么是外边距重叠？重叠的结果是什么

> 外边距重叠就是 margin-collapse

在 CSS 当中，相邻的两个盒⼦（可能是兄弟关系也可能是祖先关系）的外边距可以结合成
⼀个单独的外边距。这种合并外边距的⽅式被称为折叠，并且因⽽所结合成的外边距称为
折叠外边距

折叠结果遵循下列计算规则：

- 两个相邻的外边距都是正数时，折叠结果是它们两者之间较⼤的值。
- 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较⼤值。
- 两个外边距⼀正⼀负时，折叠结果是两者的相加的和。

### 2.39 rgba()和 opacity 的透明效果有什么不同

- rgba() 和 opacity 都能实现透明效果，但最⼤的不同是 opacity 作⽤于元素，以及元素内的所有内容的透明度
- ⽽ rgba() 只作⽤于元素的颜⾊或其背景⾊。（设置 rgba 透明的元素的⼦元素不会继承透明效果！）

### 2.40 css 中可以让⽂字在垂直和⽔平⽅向上重叠的两个属性是什么？

- 垂直⽅向： line-height
- ⽔平⽅向： letter-spacing

### 2.41 如何垂直居中⼀个浮动元素？

```css
/**⽅法⼀：已知元素的⾼宽**/
#div1 {
  background-color: #6699ff;
  width: 200px;
  height: 200px;
  position: absolute; //⽗元素需要相对定位
  top: 50%;
  left: 50%;
  margin-top: -100px; //⼆分之⼀的height，width
  margin-left: -100px;
}
/**⽅法⼆:**/
#div1 {
  width: 200px;
  height: 200px;
  background-color: #6699ff;
  margin: auto;
  position: absolute; //⽗元素需要相对定位
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
}
```

#### 如何垂直居中⼀个 \<img> ?（⽤更简便的⽅法。）

```css
#container /**<img>的容器设置如下**/ {
  display: table-cell;
  text-align: center;
  vertical-align: middle;
}
```

### 2.42 px 和 em 的区别

- px 和 em 都是⻓度单位，区别是， px 的值是固定的，指定是多少就是多少，计算⽐较容易。 em 得值不是固定的，并且 em 会继承⽗级元素的字体⼤⼩。
- 浏览器的默认字体⾼都是 16px 。所以未经调整的浏览器都符合: 1em=16px 。那么 12px=0.75em , 10px=0.625em 。

### 2.43 Sass、LESS 是什么？⼤家为什么要使⽤他们

- 他们是 CSS 预处理器。他是 CSS 上的⼀种抽象层。他们是⼀种特殊的语法/语⾔编译成 CSS
- 例如 Less 是⼀种动态样式语⾔. 将 CSS 赋予了动态语⾔的特性，如变量，继承，运算， 函数. LESS 既可以在客户端上运⾏ (⽀持 IE 6+ , Webkit , Firefox )，也可⼀在服务端运⾏ (借助 Node.js )

#### 为什么要使用他们

- 结构清晰，便于扩展。
- 可以⽅便地屏蔽浏览器私有语法差异。这个不⽤多说，封装对- 浏览器语法差异的重复处理，减少⽆意义的机械劳动。
- 可以轻松实现多重继承。
- 完全兼容 CSS 代码，可以⽅便地应⽤到⽼项⽬中。LESS 只- 是在 CSS 语法上做了扩展，所以⽼的 CSS 代码也可以与 LESS 代码⼀同编译

### 2.44 知道 css 有个 content 属性吗？有什么作⽤？有什么应⽤？

> css 的 content 属性专⻔应⽤在 before/after 伪元素上，⽤于来插⼊⽣成内容。最常⻅的应⽤是利⽤伪类清除浮动。

```css
/**⼀种常⻅利⽤伪类清除浮动的代码**/
.clearfix:after {
  content: "."; //这⾥利⽤到了content属性
  display: block;
  height: 0;
  visibility: hidden;
  clear: both;
}
.clearfix {
  *zoom: 1;
}
```

### 2.45 ⽔平居中的⽅法

- 元素为⾏内元素，设置⽗元素 text-align:center
- 如果元素宽度固定，可以设置左右 margin 为 auto ;
- 如果元素为绝对定位，设置⽗元素 position 为 relative ，元素设 left:0;right:0;margin:auto;
- 使⽤ flex-box 布局，指定 justify-content 属性为 center
- display 设置为 tabel-ceil

### 2.46 垂直居中的⽅法

- 将显示⽅式设置为表格， display:table-cell ,同时设置 vertial-align：middle
- 使⽤ flex 布局，设置为 align-item：center
- 绝对定位中设置 bottom:0,top:0 ,并设置 margin:auto
- 绝对定位中固定⾼度时设置 top:50%，margin-top 值为⾼度⼀半的负值
- ⽂本垂直居中设置 line-height 为 height 值

### 2.47 如何使⽤ CSS 实现硬件加速

> 硬件加速是指通过创建独⽴的复合图层，让 GPU 来渲染这个图层，从⽽提⾼性能

- ⼀般触发硬件加速的 CSS 属性有 transform 、 opacity 、 filter ，为了避免 2D 动画在 开始和结束的时候的 repaint 操作，⼀般使⽤ tranform:translateZ(0)

### 2.48 重绘和回流（重排）是什么，如何避免

- DOM 的变化影响到了元素的⼏何属性（宽⾼）,浏览器重新计算元素的⼏何属性，其他元素的⼏何属性和位置也会受到影响，浏览器需要重新构造渲染树，这个过程称为重排
- 浏览器将受到影响的部分重新绘制到屏幕上的过程称为重绘
- 引起重排的原因有
  - 添加或者删除可⻅的 DOM 元素，
  - 元素位置、尺⼨、内容改变，
  - 浏览器⻚⾯初始化，
  - 浏览器窗⼝尺⼨改变，重排⼀定重绘，重绘不⼀定重排
- 减少重绘和重排的⽅法：
  - 不在布局信息改变时做 DOM 查询
  - 使⽤ cssText 或者 className ⼀次性改变属性
  - 使⽤ fragment
  - 对于多次重排的元素，如动画，使⽤绝对定位脱离⽂档流，让他的改变不影响到其他元素

### 2.49 说⼀说 css3 的 animation

- css3 的 animation 是 css3 新增的动画属性，这个 css3 动画的每⼀帧是通过 @keyframes 来声明的， keyframes 声明了动画的名称，通过 from 、 to 或者是百分⽐来定义每⼀帧动画元素的状态，通过 animation-name 来引⽤这个动画，同时 css3 动画也可以定义动画运⾏的时⻓、动画开始时间、动画播放⽅向、动画循环次数、动画播放的⽅式，
- 这些相关的动画⼦属性有： animation-name 定义动画名、 animation-duration 定义动画播放的时⻓、 animation-delay 定义动画延迟播放的时间、 animationdirection 定义 动画的播放⽅向、 animation-iteration-count 定义播放次数、animation-fill-mode 定义动画播放之后的状态、 animation-play-state 定义播放状态，如暂停运⾏等、 animation-timing-function 定义播放的⽅式，如恒速播放、艰涩播放等。

### 2.50 左边宽度固定，右边⾃适应

> 左侧固定宽度，右侧⾃适应宽度的两列布局实现

```html
<div class="outer">
  <div class="left">固定宽度</div>
  <div class="right">⾃适应宽度</div>
</div>
```

> 在外层 div （类名为 outer ）的 div 中，有两个⼦ div ，类名分别为 left 和 right ，其中 left 为固定宽度，⽽ right 为⾃适应宽度

```css
.outer {
  width: 100%;
  height: 500px;
  background-color: yellow;
}
.left {
  width: 200px;
  height: 200px;
  background-color: red;
  float: left;
}
.right {
  height: 200px;
  background-color: blue;
}
```

> 对右侧:div 进⾏绝对定位，然后再设置 right=0，即可以实现宽度⾃适应
>
> 绝对定位元素的第⼀个⾼级特性就是其具有⾃动伸缩的功能，当我们将 width 设置为 auto 的时候（或者不设置，默认为 auto ），绝对定位元素会根据其 left 和 right ⾃动伸缩其⼤⼩

```css
.outer {
  width: 100%;
  height: 500px;
  background-color: yellow;
  position: relative;
}
.left {
  width: 200px;
  height: 200px;
  background-color: red;
}
.right {
  height: 200px;
  background-color: blue;
  position: absolute;
  left: 200px;
  top: 0;
  right: 0;
}
```

> 将左侧 div 进⾏绝对定位，然后右侧 div 设置 margin-left: 200px

```css
.outer {
  width: 100%;
  height: 500px;
  background-color: yellow;
  position: relative;
}
.left {
  width: 200px;
  height: 200px;
  background-color: red;
  position: absolute;
}
.right {
  height: 200px;
  background-color: blue;
  margin-left: 200px;
}
```

> 使⽤ flex 布局

```css
.outer {
  width: 100%;
  height: 500px;
  background-color: yellow;
  display: flex;
  flex-direction: row;
}
.left {
  width: 200px;
  height: 200px;
  background-color: red;
}
.right {
  height: 200px;
  background-color: blue;
  flex: 1;
}
```

### 2.51 两种以上⽅式实现已知或者未知宽度的垂直⽔平居中

```css
/** 1 **/
.wraper {
  position: relative;
  .box {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 100px;
    height: 100px;
    margin: -50px 0 0 -50px;
  }
}
/** 2 **/
.wraper {
  position: relative;
  .box {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }
}
/** 3 **/
.wraper {
  .box {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100px;
  }
}
/** 4 **/
.wraper {
  display: table;
  .box {
    display: table-cell;
    vertical-align: middle;
  }
}
```

### 2.52 如何实现⼩于 12px 的字体效果

> transform:scale() 这个属性只可以缩放可以定义宽⾼的元素，⽽⾏内元素是没有宽⾼的，我们可以加上⼀个 display:inline-block ;

```css
 {
  transform: scale(0.7);
}
```

css 的属性，可以缩放⼤⼩

## 3 JavaScript

### 3.1 闭包

- 闭包就是能够读取其他函数内部变量的函数
- 闭包是指有权访问另⼀个函数作⽤域中变量的函数，创建闭包的最常⻅的⽅式就是在⼀个函数内创建另⼀个函数，通过另⼀个函数访问这个函数的局部变量,利⽤闭包可以突破作⽤链域
- 闭包的特性：
  - 函数内再嵌套函数
  - 内部函数可以引⽤外层的参数和变量
  - 参数和变量不会被垃圾回收机制回收

#### 说说你对闭包的理解

- 使⽤闭包主要是为了设计私有的⽅法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增⼤内存使⽤量，使⽤不当很容易造成内存泄露。在 js 中，函数即闭包，只有函数才会产⽣作⽤域的概念
- 闭包 的最⼤⽤处有两个，⼀个是可以读取函数内部的变量，另⼀个就是让这些变量始终保持在内存中
- 闭包的另⼀个⽤处，是封装对象的私有属性和私有⽅法
- 好处：能够实现封装和缓存等；
- 坏处：就是消耗内存、不正当使⽤会造成内存溢出的问题

#### 使⽤闭包的注意点

- 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很⼤，所以不能滥⽤闭包，否则会造成⽹⻚的性能问题，在 IE 中可能导致内存泄露
- 解决⽅法是，在退出函数之前，将不使⽤的局部变量全部删除

### 3.2 说说你对作⽤域链的理解

- 作⽤域链的作⽤是保证执⾏环境⾥有权访问的变量和函数是有序的，作⽤域链的变量只能向上访问，变量访问到 window 对象即被终⽌，作⽤域链向下访问变量是不被允许的
- 简单的说，作⽤域就是变量与函数的可访问范围，即作⽤域控制着变量与函数的可⻅性和⽣命周期

### 3.3 JavaScript 原型，原型链 ? 有什么特点？

- 每个对象都会在其内部初始化⼀个属性，就是 prototype (原型)，
- 当我们访问⼀个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去 prototype ⾥找这个属性，这个 prototype ⼜会有⾃⼰的 prototype ，于是就这样⼀直找下去，也就是我们平时所说的原型链的概念
- 关系： instance.constructor.prototype = instance.**proto**
- 特点
  - JavaScript 对象是通过引⽤来传递的，我们创建的每个新对象实体中并没有⼀份属于⾃⼰的原型副本。当我们修改原型时，与之相关的对象也会继承这⼀改变
  - 当我们需要⼀个属性的时， Javascript 引擎会先看当前对象中是否有这个属性， 如果没有的就会查找他的 Prototype 对象是否有这个属性，如此递推下去，⼀直检索到 Object 内建对象

### 2.4 请解释什么是事件代理

- 事件代理（ Event Delegation ），⼜称之为事件委托。是 JavaScript 中常⽤绑定事件的常⽤技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给⽗元素，让⽗元素担当事件监听的职务。事件代理的原理是 DOM 元素的事件冒泡。使⽤事件代理的好处是可以提⾼性能
- 可以⼤量节省内存占⽤，减少事件注册，⽐如在 table 上代理所有 td 的 click 事件就⾮常棒
- 可以实现当新增⼦对象时⽆需再次对其绑定

### 2.5 Javascript 如何实现继承？

- 构造继承
- 原型继承
- 实例继承
- 拷贝继承
- 原型 prototype 机制或 apply 和 call ⽅法去实现较简单，建议使⽤构造函数与原型混合⽅式

```js
function Parent() {
  this.name = "wang";
}
function Child() {
  this.age = 28;
}

Child.prototype = new Parent(); //继承了Parent，通过原型
var demo = new Child();
alert(demo.age);
alert(demo.name); //得到被继承的属性
```

建议看：<https://blog.shenzjd.com/pages/b58b52fcbc575/>

### 3.6 谈谈 This 对象的理解

- this 总是指向函数的直接调⽤者（⽽⾮间接调⽤者）
- 如果有 new 关键字， this 指向 new 出来的那个对象
- 在事件中， this 指向触发这个事件的对象，特殊的是， IE 中的 attachEvent 中的 this 总是指向全局对象 Window

### 3.7 事件模型

> W3C 中定义事件的发⽣经历三个阶段：捕获阶段（ capturing ）、⽬标阶段（ targetin ）、冒泡阶段（ bubbling ）

- 捕获型事件：当你使⽤事件捕获时，⽗级元素先触发，⼦级元素后触发
- 冒泡型事件：当你使⽤事件冒泡时，⼦级元素先触发，⽗级元素后触发
- DOM 事件流：同时⽀持两种事件模型：捕获型事件和冒泡型事件
- 阻⽌冒泡：在 W3c 中，使⽤ stopPropagation() ⽅法；在 IE 下设置 cancelBubble = true
- 阻⽌捕获：阻⽌事件的默认⾏为，例如 click - \<a> 后的跳转。在 W3c 中，使⽤ preventDefault() ⽅法，在 IE 下设置 window.event.returnValue = false

### 3.8 new 操作符具体⼲了什么呢?

- 创建⼀个空对象，并且 this 变量引⽤该对象，同时还继承了该函数的原型
- 属性和⽅法被加⼊到 this 引⽤的对象中
- 新创建的对象由 this 所引⽤，并且最后隐式的返回 this

建议看： <https://blog.shenzjd.com/pages/71d970640a8d9/>

### 3.9 Ajax 原理

- Ajax 的原理简单来说是在⽤户和服务器之间加了—个中间层( AJAX 引擎)，通过 XmlHttpRequest 对象来向服务器发异步请求，从服务器获得数据，然后⽤ javascript 来操作 DOM ⽽更新⻚⾯。使⽤户操作与服务器响应异步化。这其中最关键的⼀步就是从服务器获得请求数据
- Ajax 的过程只涉及 JavaScript 、 XMLHttpRequest 和 DOM 。 XMLHttpRequest 是 ajax 的核⼼机制

```js
/** 1. 创建连接 **/
var xhr = null;
xhr = new XMLHttpRequest();
/** 2. 连接服务器 **/
xhr.open("get", url, true);
/** 3. 发送请求 **/
xhr.send(null);
/** 4. 接受请求 **/
xhr.onreadystatechange = function () {
  if (xhr.readyState == 4) {
    if (xhr.status == 200) {
      success(xhr.responseText);
    } else {
      /** false **/
      fail && fail(xhr.status);
    }
  }
};
```

#### ajax 有那些优缺点?

- 优点：
  - 通过异步模式，提升了⽤户体验.
  - 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占⽤.
  - Ajax 在客户端运⾏，承担了⼀部分本来由服务器承担的⼯作，减少了⼤⽤户量下的服务器负载。
  - Ajax 可以实现动态不刷新（局部刷新）
- 缺点：
  - 安全问题 AJAX 暴露了与服务器交互的细节。
  - 对搜索引擎的⽀持⽐较弱。
  - 不容易调试。

### 3.10 如何解决跨域问题?

> ⾸先了解下浏览器的同源策略 同源策略 /SOP（Same origin policy） 是⼀种约定，由 Netscape 公司 1995 年引⼊浏览器，它是浏览器最核⼼也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS 、 CSFR 等攻击。所谓同源是指"协议+域名+端⼝"三者相同，即便两个不同的域名指向同⼀个 ip 地址，也⾮同源

#### 那么怎样解决跨域问题的呢？

- 通过 jsonp 跨域

```js
var script = document.createElement("script");
script.type = "text/javascript";
// 传参并指定回调执⾏函数为onBack
script.src = "http://www.....:8080/login?user=admin&callback=onBack";
document.head.appendChild(script);
// 回调执⾏函数
function onBack(res) {
  alert(JSON.stringify(res));
}
```

- document.domain + iframe 跨域

> 此⽅案仅限主域相同，⼦域不同的跨域应⽤场景

1.）⽗窗⼝：(<http://www.domain.com/a.html>)

```html
<iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
<script>
  document.domain = "domain.com";
  var user = "admin";
</script>
```

2.）⼦窗⼝：(<http://child.domain.com/b.html>)

```js
document.domain = "domain.com";
// 获取⽗窗⼝中变量
alert("get js data from parent ---> " + window.parent.user);
```

- nginx 代理跨域
- nodejs 中间件代理跨域
- 后端在头部信息⾥⾯设置安全域名

### 3.11 模块化开发怎么做？

- ⽴即执⾏函数,不暴露私有成员

```js
var module1 = (function () {
  var _count = 0;
  var m1 = function () {
    //...
  };
  var m2 = function () {
    //...
  };
  return {
    m1: m1,
    m2: m2,
  };
})();
```

### 3.12 异步加载 JS 的⽅式有哪些

- defer，只⽀持 IE
- async ：
- 创建 script ，插⼊到 DOM 中，加载完毕后 callBack

### 3.13 那些操作会造成内存泄漏

- 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在
- setTimeout 的第⼀个参数使⽤字符串⽽⾮函数的话，会引发内存泄漏
- 闭包使⽤不当

### 3.14 XML 和 JSON 的区别

- 数据体积⽅⾯
  - JSON 相对 于 XML 来讲，数据的体积⼩，传递的速度更快些。
- 数据交互⽅⾯
  - JSON 与 JavaScript 的交互更加⽅便，更容易解析处理，更好的数据交互
- 数据描述⽅⾯
  - JSON 对数据的描述性⽐ XML 较差
- 传输速度⽅⾯
  - JSON 的速度要远远快于 XML

### 3.15 谈谈你对 webpack 的看法

> WebPack 是⼀个模块打包⼯具，你可以使⽤ WebPack 管理你的模块依赖，并编绎输出模块们所需的静态⽂件。它能够很好地管理、打包 Web 开发中所⽤到的 HTML 、Javascript 、 CSS 以及各种静态⽂件（图⽚、字体等），让开发过程更加⾼效。对于不同类型的资源， webpack 有对应的模块加载器。 webpack 模块打包器会分析模块间的依赖关系，最后 ⽣成了优化且合并后的静态资源

### 3.16 说说你对 AMD 和 Commonjs 的理解

- CommonJS 是服务器端模块的规范， Node.js 采⽤了这个规范。 CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执⾏后⾯的操作。 AMD 规范则是⾮同步加载模块，允许指定回调函数
- AMD 推荐的⻛格通过返回⼀个对象做为模块对象， CommonJS 的⻛格通过对 module.exports 或 exports 的属性赋值来达到暴露模块对象的⽬的

这个上面答案不推荐，直接看这个： <https://blog.shenzjd.com/pages/a7e7fa4fe512d/>

### 3.17 常⻅ web 安全及防护原理

#### sql 注⼊原理

> 就是通过把 SQL 命令插⼊到 Web 表单递交或输⼊域名或⻚⾯请求的查询字符串，最终达到欺骗服务器执⾏恶意的 SQL 命令

总的来说有以下⼏点

- 永远不要信任⽤户的输⼊，要对⽤户的输⼊进⾏校验，可以通过正则表达式，或限制⻓度，对单引号和双 "-" 进⾏转换等
- 永远不要使⽤动态拼装 SQL，可以使⽤参数化的 SQL 或者直接使⽤存储过程进⾏数据查询存取
- 永远不要使⽤管理员权限的数据库连接，为每个应⽤使⽤单独的权限有限的数据库连接
- 不要把机密信息明⽂存放，请加密或者 hash 掉密码和敏感的信息

#### XSS 原理及防范

> Xss(cross-site scripting) 攻击指的是攻击者往 Web ⻚⾯⾥插⼊恶意 html 标签或者 javascript 代码。⽐如：攻击者在论坛中放⼀个看似安全的链接，骗取⽤户点击后，窃取 cookie 中的⽤户私密信息；或者攻击者在论坛中加⼀个恶意表单，当⽤户提交表单的时候，却把信息传送到攻击者的服务器中，⽽不是⽤户原本以为的信任站点

#### XSS 防范⽅法

- ⾸先代码⾥对⽤户输⼊的地⽅和变量都需要仔细检查⻓度和对 ”<”,”>”,”;”,”’” 等字符做过滤；其次任何内容写到⻚⾯之前都必须加以 encode，避免不⼩⼼把 html tag 弄出来。这⼀个层⾯做好，⾄少可以堵住超过⼀半的 XSS 攻击

#### XSS 与 CSRF 有什么区别吗？

> XSS 是获取信息，不需要提前知道其他⽤户⻚⾯的代码和数据包。 CSRF 是代替⽤户完成指定的动作，需要知道其他⽤户⻚⾯的代码和数据包。

要完成⼀次 CSRF 攻击，受害者必须依次完成两个步骤

- 登录受信任⽹站 A ，并在本地⽣成 Cookie
- 在不登出 A 的情况下，访问危险⽹站 B

#### CSRF 的防御

- 服务端的 CSRF ⽅式⽅法很多样，但总的思想都是⼀致的，就是在客户端⻚⾯增加伪随机数
- 通过验证码的⽅法

建议看： <https://blog.shenzjd.com/pages/62502f3dd8041/>

### 3.18 ⽤过哪些设计模式

- ⼯⼚模式：
  - ⼯⼚模式解决了重复实例化的问题，但还有⼀个问题,那就是识别问题，因为根本⽆法
  - 主要好处就是可以消除对象间的耦合，通过使⽤⼯程⽅法⽽不是 new 关键字
- 构造函数模式
  - 使⽤构造函数的⽅法，即解决了重复实例化的问题，⼜解决了对象识别的问题，该模式与⼯⼚模式的不同之处在于直接将属性和⽅法赋值给 this 对象;

建议看： <https://blog.shenzjd.com/pages/59f0a81f8307b/>

### 3.19 为什么要有同源限制

- 同源策略指的是：协议，域名，端⼝相同，同源策略是⼀种安全协议
- 举例说明：⽐如⼀个⿊客程序，他利⽤ Iframe 把真正的银⾏登录⻚⾯嵌到他的⻚⾯上，当你使⽤真实的⽤户名，密码登录时，他的⻚⾯就可以通过 Javascript 读取到你的表单中 input 中的内容，这样⽤户名，密码就轻松到⼿了。

### 3.20 offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别

- offsetWidth/offsetHeight 返回值包含 content + padding + border，效果与 e.getBoundingClientRect()相同
- clientWidth/clientHeight 返回值只包含 content + padding，如果有滚动条，也不包含滚动条
- scrollWidth/scrollHeight 返回值包含 content + padding + 溢出内容的尺⼨

### 3.21 javascript 有哪些⽅法定义对象

- 对象字⾯量： var obj = {};
- 构造函数： var obj = new Object();
- Object.create(): var obj = Object.create(Object.prototype);

### 3.22 常⻅兼容性问题

- png24 位的图⽚在 iE6 浏览器上出现背景，解决⽅案是做成 PNG8
- 浏览器默认的 margin 和 padding 不同。解决⽅案是加⼀个全局的 \*{margin:0;padding:0;} 来统⼀,，但是全局效率很低，⼀般是如下这样解决：
- IE 下, event 对象有 x , y 属性,但是没有 pageX , pageY 属性
- Firefox 下, event 对象有 pageX , pageY 属性,但是没有 x,y 属性.

### 3.23 说说你对 promise 的了解

- 依照 Promise/A+ 的定义， Promise 有四种状态：
  - pending: 初始状态, ⾮ fulfilled 或 rejected.
  - fulfilled: 成功的操作.
  - rejected: 失败的操作.
  - settled: Promise 已被 fulfilled 或 rejected ，且不是 pending
- 另外， fulfilled 与 rejected ⼀起合称 settled
- Promise 对象⽤来进⾏延迟( deferred ) 和异步( asynchronous ) 计算

#### Promise 的构造函数

构造⼀个 Promise ，最基本的⽤法如下：

```js
var promise = new Promise(function(resolve, reject) {
  if (...) { // succeed
    resolve(result);
  } else { // fails
    reject(Error(errMessage));
  }
 });
```

- Promise 实例拥有 then ⽅法（具有 then ⽅法的对象，通常被称为 thenable ）
- 接收两个函数作为参数，⼀个在 fulfilled 的时候被调⽤，⼀个在 rejected 的时候被调⽤，接收参数就是 future ，onFulfilled 对应 resolve , onRejected 对应 reject

### 3.24 你觉得 jQuery 源码有哪些写的好的地⽅

- jquery 源码封装在⼀个匿名函数的⾃执⾏环境中，有助于防⽌变量的全局污染，然后通过传⼊ window 对象参数，可以使 window 对象作为局部变量使⽤，好处是当 jquery 中访问 window 对象的时候，就不⽤将作⽤域链退回到顶层作⽤域了，从⽽可以更快的访问
  window 对象。同样，传⼊ undefined 参数，可以缩短查找 undefined 时的作⽤域链
- jquery 将⼀些原型属性和⽅法封装在了 jquery.prototype 中，为了缩短名称，⼜赋值给了 jquery.fn ，这是很形象的写法
- 有⼀些数组或对象的⽅法经常能使⽤到， jQuery 将其保存为局部变量以提⾼访问速度
- jquery 实现的链式调⽤可以节约代码，所返回的都是同⼀个对象，可以提⾼代码效率

### 3.25 vue、react、angular

- Vue.js ⼀个⽤于创建 web 交互界⾯的库，是⼀个精简的 MVVM 。它通过双向数据绑定把 View 层和 Model 层连接了起来。实际的 DOM 封装和输出格式都被抽象为了 Directives 和 Filters
- AngularJS 是⼀个⽐较完善的前端 MVVM 框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注⼊等所有功能，模板功能强⼤丰富，⾃带了丰富的 Angular 指令
- react React 仅仅是 VIEW 层是 facebook 公司。推出的⼀个⽤于构建 UI 的⼀个库，能够实现服务器端的渲染。⽤了 virtual dom ，所以性能很好。

### 3.26 Node 的应⽤场景

- 特点：
  - 1、它是⼀个 Javascript 运⾏环境
  - 2、依赖于 Chrome V8 引擎进⾏代码解释
  - 3、事件驱动
  - 4、⾮阻塞 I/O
  - 5、单进程，单线程
- 优点：
  - ⾼并发（最重要的优点）
- 缺点：
  - 1、只⽀持单核 CPU ，不能充分利⽤ CPU
  - 2、可靠性低，⼀旦代码某个环节崩溃，整个系统都崩溃

### 3.27 谈谈你对 AMD、CMD 的理解

- CommonJS 是服务器端模块的规范， Node.js 采⽤了这个规范。 CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执⾏后⾯的操作。 AMD 规范则是⾮同步加载模块，允许指定回调函数
- AMD 推荐的⻛格通过返回⼀个对象做为模块对象， CommonJS 的⻛格通过对 module.exports 或 exports 的属性赋值来达到暴露模块对象的⽬的

#### es6 模块 CommonJS、AMD、CMD

- CommonJS 的规范中，每个 JavaScript ⽂件就是⼀个独⽴的模块上下⽂（ module context ），在这个上下⽂中默认创建的属性都是私有的。也就是说，在⼀个⽂件定义的变量（还包括函数和类），都是私有的，对其他⽂件是不可⻅的。
- CommonJS 是同步加载模块,在浏览器中会出现堵塞情况，所以不适⽤
- AMD 异步，需要定义回调 define ⽅式
- es6 ⼀个模块就是⼀个独⽴的⽂件，该⽂件内部的所有变量，外部⽆法获取。如果你希望外部能够读取模块内部的某个变量，就必须使⽤ export 关键字输出该变量 es6 还可以导出类、⽅法，⾃动适⽤严格模式

### 3.28 那些操作会造成内存泄漏

- 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在
- setTimeout 的第⼀个参数使⽤字符串⽽⾮函数的话，会引发内存泄漏
- 闭包、控制台⽇志、循环（在两个对象彼此引⽤且彼此保留时，就会产⽣⼀个循环）

### 3.29 web 开发中会话跟踪的⽅法有哪些

- cookie
- session
- url 重写
- 隐藏 input
- ip 地址

### 3.30 介绍 js 的基本数据类型

Undefined 、 Null 、 Boolean 、 Number 、 String、symbol、bigInt

### 介绍 js 有哪些内置对象

- Object 是 JavaScript 中所有对象的⽗对象
- 数据封装类对象： Object 、 Array 、 Boolean 、 Number 和 String
- 其他对象： Function 、 Arguments 、 Math 、 Date 、 RegExp 、 Error

## PDF 下载

<https://docs.qq.com/pdf/DV3RpdGR5R2NhbUVI>
