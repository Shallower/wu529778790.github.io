---
title: 进阶篇
date: 2022-04-21 11:00:19
permalink: /pages/9c29865395124/
categories:
  - 面试突击
tags:
  -
---

【腾讯文档】2、第二部分：进阶篇(30 题).
<https://docs.qq.com/pdf/DV0VDSkZFeVNGZkNy>

<!-- more -->

## JS

### 变量提升

> 当执行 js 代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境，只有这两种执行环境。

```js
b(); // call b
console.log(a); // undefined
var a = "Hello world";
function b() {
  console.log("call b");
}
```

> 想必以上的输出⼤家肯定都已经明⽩了，这是因为函数和变量提升的原因。通
> 常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于⼤
> 家理解。但是更准确的解释应该是：在⽣成执⾏环境时，会有两个阶段。第⼀
> 个阶段是创建的阶段， JS 解释器会找出需要提升的变量和函数，并且给他们
> 提前在内存中开辟好空间，函数的话会将整个函数存⼊内存中，变量只声明并
> 且赋值为 undefined ，所以在第⼆个阶段，也就是代码执⾏阶段，我们可以
> 直接提前使⽤

在提升的过程中，相同的函数会覆盖上⼀个函数，并且函数优先于变量提升

```js
b(); // call b second
function b() {
  console.log("call b fist");
}
function b() {
  console.log("call b second");
}
var b = "Hello world";
```

> var 会产⽣很多错误，所以在 ES6 中引⼊了 let 。 let 不能在声明前使
> ⽤，但是这并不是常说的 let 不会提升， let 提升了，在第⼀阶段内存也
> 已经为他开辟好了空间，但是因为这个声明的特性导致了并不能在声明前使⽤

### bind、call、apply 区别

call 和 apply 都是为了解决改变 this 的指向。作⽤都是相同的，只是传参的⽅式
不同。

除了第⼀个参数外， call 可以接收⼀个参数列表， apply 只接受⼀个参数数组

```js
let a = {
  value: 1,
};
function getValue(name, age) {
  console.log(name);
  console.log(age);
  console.log(this.value);
}
getValue.call(a, "shenzjd.com", "666");
getValue.apply(a, ["shenzjd.com", "666"]);
```

> bind 和其他两个⽅法作⽤也是⼀致的，只是该⽅法会返回⼀个函数。并且我
> 们可以通过 bind 实现柯⾥化

### 如何实现⼀个 call 函数

```js
Function.prototype.myCall = function (context) {
  var context = context || window;
  // 给 context 添加⼀个属性
  // getValue.call(a, 'yck', '24') => a.fn = getValue
  context.fn = this;
  // 将 context 后⾯的参数取出来
  var args = [...arguments].slice(1);
  // getValue.call(a, 'yck', '24') => a.fn('yck', '24')
  var result = context.fn(...args);
  // 删除 fn
  delete context.fn;
  return result;
};
```

上面的是 yck 写的，但是我更推荐神三元的写法

```js
Function.prototype.call = function (context, ...args) {
  let context = context || window;
  context.fn = this;
  let result = context.fn(...args);
  delete context.fn;
  return result;
};
```

### 如何实现⼀个 apply 函数

```js
Function.prototype.myApply = function (context) {
  var context = context || window;
  context.fn = this;
  var result;
  // 需要判断是否存储第⼆个参数
  // 如果存在，就将第⼆个参数展开
  if (arguments[1]) {
    result = context.fn(...arguments[1]);
  } else {
    result = context.fn();
  }
  delete context.fn;
  return result;
};
```

上面的是 yck 写的，但是我更推荐神三元的写法,这里的 apply 只是接收参数的区别

```js
Function.prototype.apply = function (context, args) {
  let context = context || window;
  context.fn = this;
  let result = context.fn(...args);
  delete context.fn;
  return result;
};
```

### 如何实现⼀个 bind 函数

对于实现以下⼏个函数，可以从⼏个⽅⾯思考

- 不传⼊第⼀个参数，那么默认为 window
- 改变了 this 指向，让新的对象可以执⾏该函数。那么思路是否可以变成给新的对象添加⼀个函数，然后在执⾏完以后删除？

```js
Function.prototype.myBind = function (context) {
  if (typeof this !== "function") {
    throw new TypeError("Error");
  }
  var _this = this;
  var args = [...arguments].slice(1);
  // 返回⼀个函数
  return function F() {
    // 因为返回了⼀个函数，我们可以 new F()，所以需要判断
    if (this instanceof F) {
      return new _this(...args, ...arguments);
    }
    return _this.apply(context, args.concat(...arguments));
  };
};
```

上面的是 yck 写的，但是我更推荐神三元的写法

```js
Function.prototype.bind = function (context, ...args) {
  if (typeof this !== "function") {
    throw new Error("this must be a function");
  }
  var that = this;
  var fbound = function () {
    that.call(context, ...args, arguments);
  };
  if (this.prototype) {
    fbound.prototype = Object.create(this.prototype);
  }
  return fbound;
};
```

更多手写访问：<https://blog.shenzjd.com/pages/7a05690c28407/>

### 简单说下原型链

- 每个函数都有 prototype 属性，除了 Function.prototype.bind(),该属性指向原型。
- 每个独享都有\_\_proto\_\_属性，指向了创建该对象的构造函数的原型。其实这个属性指向了[[prototype]]，但是[[prototype]]是内部属性，我们并不能访问到，所以用\_\_proto\_\_来访问。
- 对象可以通过\_\_proto\_\_来寻找不属于该对象的属性，\_\_proto\_\_将对象连接起来组成了原型链

原型链推荐看这个：<https://blog.shenzjd.com/pages/680e335c611f2/>

### 箭头函数的特点

```js
function a() {
  return () => {
    return () => {
      console.log(this);
    };
  };
}
console.log(a()()());
```

> 箭头函数其实是没有 this 的，这个函数中的 this 只取决于他外⾯的第⼀
> 个不是箭头函数的函数的 this 。在这个例⼦中，因为调⽤ a 符合前⾯代
> 码中的第⼀个情况，所以 this 是 window 。并且 this ⼀旦绑定了上下
> ⽂，就不会被任何代码改变

### this

```js
function foo() {
  console.log(this.a);
}
var a = 1;
foo(); // 1
var obj = {
  a: 2,
  foo: foo,
};
obj.foo(); // 2

// 以上两者情况 `this` 只依赖于调⽤函数前的对象，优先级是第⼆个情况⼤于第⼀个情况
// 以下情况是优先级最⾼的，`this` 只会绑定在 `c` 上，不会被任何⽅式修改 `this` 指向
var c = new foo();
c.a = 3;
console.log(c.a); // 3
// 还有种就是利⽤ call，apply，bind 改变 this，这个优先级仅次于 new
```

### async,await

> async 和 await 相⽐直接使⽤ Promise 来说，优势在于处理 then 的调
> ⽤链，能够更清晰准确的写出代码。缺点在于滥⽤ await 可能会导致性能问
> 题，因为 await 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然
> 需要等待前者完成，导致代码失去了并发性

```js
var a = 0;
var b = async () => {
  a = a + (await 10);
  console.log("2", a); // -> '2' 10
  a = (await 10) + a;
  console.log("3", a); // -> '3' 20
};
b();
a++;
console.log("1", a); // -> '1' 1
```

- ⾸先函数 b 先执⾏，在执⾏到 await 10 之前变量 a 还是 0 ，因为在 await 内部
  实现了 generators ， generators 会保留堆栈中东⻄，所以这时候 a = 0 被保存了
  下来
- 因为 await 是异步操作，遇到 await 就会⽴即返回⼀个 pending 状态的 Promise 对
  象，暂时返回执⾏代码的控制权，使得函数外的代码得以继续执⾏，所以会先执⾏
  console.log('1', a)
- 这时候同步代码执⾏完毕，开始执⾏异步代码，将保存下来的值拿出来使⽤，这时候 a =
  10
- 然后后⾯就是常规执⾏代码了

## generator 原理

> Generator 是 ES6 中新增的语法，和 Promise ⼀样，都可以⽤来异步编
> 程

```js
// 使⽤ * 表示这是⼀个 Generator 函数
// 内部可以通过 yield 暂停代码
// 通过调⽤ next 恢复执⾏
function* test() {
  let a = 1 + 2;
  yield 2;
  yield 3;
}
let b = test();
console.log(b.next()); // > { value: 2, done: false }
console.log(b.next()); // > { value: 3, done: false }
console.log(b.next()); // > { value: undefined, done: true }
```

> 从以上代码可以发现，加上 \* 的函数执⾏后拥有了 next 函数，也就是说
> 函数执⾏后返回了⼀个对象。每次调⽤ next 函数可以继续执⾏被暂停的代
> 码。以下是 Generator 函数的简单实现

```js
// cb 也就是编译过的 test 函数
function generator(cb) {
  return (function () {
    var object = {
      next: 0,
      stop: function () {},
    };
    return {
      next: function () {
        var ret = cb(object);
        if (ret === undefined) return { value: undefined, done: true };
        return {
          value: ret,
          done: false,
        };
      },
    };
  })();
}

// 如果你使⽤ babel 编译后可以发现 test 函数变成了这样
function test() {
  var a;
  return generator(function (_context) {
    while (1) {
      switch ((_context.prev = _context.next)) {
        // 可以发现通过 yield 将代码分割成⼏块
        // 每次执⾏ next 函数就执⾏⼀块代码
        // 并且表明下次需要执⾏哪块代码
        case 0:
          a = 1 + 2;
          _context.next = 4;
          return 2;
        case 4:
          _context.next = 6;
          return 3;
        // 执⾏完毕
        case 6:
        case "end":
          return _context.stop();
      }
    }
  });
}
```

## Promise

- Promise 是 ES6 新增的语法，解决了回调地狱的问题。
- 可以把 Promise 看成⼀个状态机。初始是 pending 状态，可以通过函数 resolve 和
  reject ，将状态转变为 resolved 或者 rejected 状态，状态⼀旦改变就不能再次变
  化。
- then 函数会返回⼀个 Promise 实例，并且该返回值是⼀个新的实例⽽不是之前的实
  例。因为 Promise 规范规定除了 pending 状态，其他状态是不可以改变的，如果返回
  的是⼀个相同实例的话，多个 then 调⽤就失去意义了。 对于 then 来说，本质上可以
  把它看成是 flatMap

promise 可以看这个： <https://blog.shenzjd.com/pages/e1e76b9843736/#promise-a-%E8%A7%84%E8%8C%83>

## 手写 promise

```js
// 三种状态
const PENDING = "pending";
const RESOLVED = "resolved";
const REJECTED = "rejected";
// promise 接收⼀个函数参数，该函数会⽴即执⾏
function MyPromise(fn) {
  let _this = this;
  _this.currentState = PENDING;
  _this.value = undefined;
  // ⽤于保存 then 中的回调，只有当 promise
  // 状态为 pending 时才会缓存，并且每个实例⾄多缓存⼀个
  _this.resolvedCallbacks = [];
  _this.rejectedCallbacks = [];
  _this.resolve = function (value) {
    if (value instanceof MyPromise) {
      // 如果 value 是个 Promise，递归执⾏
      return value.then(_this.resolve, _this.reject);
    }
    setTimeout(() => {
      // 异步执⾏，保证执⾏顺序
      if (_this.currentState === PENDING) {
        _this.currentState = RESOLVED;
        _this.value = value;
        _this.resolvedCallbacks.forEach((cb) => cb());
      }
    });
  };
  _this.reject = function (reason) {
    setTimeout(() => {
      // 异步执⾏，保证执⾏顺序
      if (_this.currentState === PENDING) {
        _this.currentState = REJECTED;
        _this.value = reason;
        _this.rejectedCallbacks.forEach((cb) => cb());
      }
    });
  };
  // ⽤于解决以下问题
  // new Promise(() => throw Error('error))
  try {
    fn(_this.resolve, _this.reject);
  } catch (e) {
    _this.reject(e);
  }
}
MyPromise.prototype.then = function (onResolved, onRejected) {
  var self = this;
  // 规范 2.2.7，then 必须返回⼀个新的 promise
  var promise2;
  // 规范 2.2.onResolved 和 onRejected 都为可选参数
  // 如果类型不是函数需要忽略，同时也实现了透传
  // Promise.resolve(4).then().then((value) => console.log(value))
  onResolved = typeof onResolved === "function" ? onResolved : (v) => v;
  onRejected = typeof onRejected === "function" ? onRejected : (r) => throw r;
  if (self.currentState === RESOLVED) {
    return (promise2 = new MyPromise(function (resolve, reject) {
      // 规范 2.2.4，保证 onFulfilled，onRjected 异步执⾏
      // 所以⽤了 setTimeout 包裹下
      setTimeout(function () {
        try {
          var x = onResolved(self.value);
          resolutionProcedure(promise2, x, resolve, reject);
        } catch (reason) {
          reject(reason);
        }
      });
    }));
  }
  if (self.currentState === REJECTED) {
    return (promise2 = new MyPromise(function (resolve, reject) {
      setTimeout(function () {
        // 异步执⾏onRejected
        try {
          var x = onRejected(self.value);
          resolutionProcedure(promise2, x, resolve, reject);
        } catch (reason) {
          reject(reason);
        }
      });
    }));
  }
  if (self.currentState === PENDING) {
    return (promise2 = new MyPromise(function (resolve, reject) {
      self.resolvedCallbacks.push(function () {
        // 考虑到可能会有报错，所以使⽤ try/catch 包裹
        try {
          var x = onResolved(self.value);
          resolutionProcedure(promise2, x, resolve, reject);
        } catch (r) {
          reject(r);
        }
      });
      self.rejectedCallbacks.push(function () {
        try {
          var x = onRejected(self.value);
          resolutionProcedure(promise2, x, resolve, reject);
        } catch (r) {
          reject(r);
        }
      });
    }));
  }
};
// 规范 2.3
function resolutionProcedure(promise2, x, resolve, reject) {
  // 规范 2.3.1，x 不能和 promise2 相同，避免循环引⽤
  if (promise2 === x) {
    return reject(new TypeError("Error"));
  }
  // 规范 2.3.2
  // 如果 x 为 Promise，状态为 pending 需要继续等待否则执⾏
  if (x instanceof MyPromise) {
    if (x.currentState === PENDING) {
      x.then(function (value) {
        // 再次调⽤该函数是为了确认 x resolve 的
        // 参数是什么类型，如果是基本类型就再次 resolve
        // 把值传给下个 then
        resolutionProcedure(promise2, value, resolve, reject);
      }, reject);
    } else {
      x.then(resolve, reject);
    }
    return;
  }
  // 规范 2.3.3.3.3
  // reject 或者 resolve 其中⼀个执⾏过得话，忽略其他的
  let called = false;
  // 规范 2.3.3，判断 x 是否为对象或者函数
  if (x !== null && (typeof x === "object" || typeof x === "function")) {
    // 规范 2.3.3.2，如果不能取出 then，就 reject
    try {
      // 规范 2.3.3.1
      let then = x.then;
      // 如果 then 是函数，调⽤ x.then
      if (typeof then === "function") {
        // 规范 2.3.3.3
        then.call(
          x,
          (y) => {
            if (called) return;
            called = true;
            // 规范 2.3.3.3.1
            resolutionProcedure(promise2, y, resolve, reject);
          },
          (e) => {
            if (called) return;
            called = true;
            reject(e);
          }
        );
      } else {
        // 规范 2.3.3.4
        resolve(x);
      }
    } catch (e) {
      if (called) return;
      called = true;
      reject(e);
    }
  } else {
    // 规范 2.3.4，x 为基本类型
    resolve(x);
  }
}
```
