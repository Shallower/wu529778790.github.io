---
title: 进阶篇
date: 2022-04-21 11:00:19
permalink: /pages/9c29865395124/
categories:
  - 面试突击
tags:
  -
---

【腾讯文档】2、第二部分：进阶篇(30 题).
<https://docs.qq.com/pdf/DV0VDSkZFeVNGZkNy>

<!-- more -->

## JS

### 变量提升

> 当执行 js 代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境，只有这两种执行环境。

```js
b(); // call b
console.log(a); // undefined
var a = "Hello world";
function b() {
  console.log("call b");
}
```

> 想必以上的输出⼤家肯定都已经明⽩了，这是因为函数和变量提升的原因。通
> 常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于⼤
> 家理解。但是更准确的解释应该是：在⽣成执⾏环境时，会有两个阶段。第⼀
> 个阶段是创建的阶段， JS 解释器会找出需要提升的变量和函数，并且给他们
> 提前在内存中开辟好空间，函数的话会将整个函数存⼊内存中，变量只声明并
> 且赋值为 undefined ，所以在第⼆个阶段，也就是代码执⾏阶段，我们可以
> 直接提前使⽤

在提升的过程中，相同的函数会覆盖上⼀个函数，并且函数优先于变量提升

```js
b(); // call b second
function b() {
  console.log("call b fist");
}
function b() {
  console.log("call b second");
}
var b = "Hello world";
```

> var 会产⽣很多错误，所以在 ES6 中引⼊了 let 。 let 不能在声明前使
> ⽤，但是这并不是常说的 let 不会提升， let 提升了，在第⼀阶段内存也
> 已经为他开辟好了空间，但是因为这个声明的特性导致了并不能在声明前使⽤

### bind、call、apply 区别

call 和 apply 都是为了解决改变 this 的指向。作⽤都是相同的，只是传参的⽅式
不同。

除了第⼀个参数外， call 可以接收⼀个参数列表， apply 只接受⼀个参数数组

```js
let a = {
  value: 1,
};
function getValue(name, age) {
  console.log(name);
  console.log(age);
  console.log(this.value);
}
getValue.call(a, "yck", "24");
getValue.apply(a, ["yck", "24"]);
```

> bind 和其他两个⽅法作⽤也是⼀致的，只是该⽅法会返回⼀个函数。并且我
> 们可以通过 bind 实现柯⾥化

### 如何实现⼀个 bind 函数

对于实现以下⼏个函数，可以从⼏个⽅⾯思考

- 不传⼊第⼀个参数，那么默认为 window
- 改变了 this 指向，让新的对象可以执⾏该函数。那么思路是否可以变成给新的对象添加⼀个函数，然后在执⾏完以后删除？

```js
Function.prototype.myBind = function (context) {
  if (typeof this !== "function") {
    throw new TypeError("Error");
  }
  var _this = this;
  var args = [...arguments].slice(1);
  // 返回⼀个函数
  return function F() {
    // 因为返回了⼀个函数，我们可以 new F()，所以需要判断
    if (this instanceof F) {
      return new _this(...args, ...arguments);
    }
    return _this.apply(context, args.concat(...arguments));
  };
};
```

### 如何实现⼀个 call 函数

```js
Function.prototype.myCall = function (context) {
  var context = context || window;
  // 给 context 添加⼀个属性
  // getValue.call(a, 'yck', '24') => a.fn = getValue
  context.fn = this;
  // 将 context 后⾯的参数取出来
  var args = [...arguments].slice(1);
  // getValue.call(a, 'yck', '24') => a.fn('yck', '24')
  var result = context.fn(...args);
  // 删除 fn
  delete context.fn;
  return result;
};
```

### 如何实现⼀个 apply 函数

```js
Function.prototype.myApply = function (context) {
  var context = context || window;
  context.fn = this;
  var result;
  // 需要判断是否存储第⼆个参数
  // 如果存在，就将第⼆个参数展开
  if (arguments[1]) {
    result = context.fn(...arguments[1]);
  } else {
    result = context.fn();
  }
  delete context.fn;
  return result;
};
```
