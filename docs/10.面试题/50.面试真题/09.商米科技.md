---
title: 商米科技
date: 2022-05-25 22:15:30
permalink: /pages/2dda8521e76fc/
categories:
  - 面试题
  - 面试真题
tags:
  -
---

## Promise

```js
var result = [1, 2, 3];
var p = Promise.resolve(result);
result = [4, 5, 6];

p.then((r) => {
  console.log("r", r);
});
```

结果竟然是`r, [1, 2, 3]`

函数参数存的已经是执行上下文，变量作用域在当前实际的值了,后续再怎么赋值已经没关系了

### 如果想要变成`[4, 5, 6]`

## 在哪里可以 catch 到报错

```js
const p1 = new Promise(...);
const p2 = p1.then(() => {
    throw 'fsdfsdf';
});
const p3 = p2.then(() => {...});
```

## 哪个会进入微任务

```js
const p = new Promise(codeA);
const p.then(codeB, codeC).catch(codeD);
```

## 面包屑

```js
const treeNodes = [
  {
    id: "001",
    text: "父节点",
    children: [
      {
        id: "001-1",
        text: "中间节点1",
        children: [],
      },
      {
        id: "001-2",
        text: "中间节点2",
        children: [
          {
            id: "001-2-1",
            text: "子节点1",
          },
          {
            id: "001-2-2",
            text: "子节点2",
          },
        ],
      },
    ],
  },
];

// 请实现一个获取面包屑的函数
function getBreadcrumbs(treeNodes, targetId) {
  // TODO 请输入您的代码；
}

const bc = getBreadcrumbs(treeNodes, "001-2-2");
console.log(bc); // 此次将打印 父节点/中间节点2/子节点2
```

`深度优先遍历、广度优先遍历、回溯`

> 抽空再把算法拾起来吧，o(╥﹏╥)o

刚开始看到这道题的时候，一看面包屑，自己项目还写过，一写才发现想简单了

### 笨方法，取巧了，利用 id 的规律

也算是一种深度优先遍历

```js
function getBreadcrumbs(treeNodes, targetId) {
  const ids = targetId.split("-");
  let index = 0;
  let result = "";
  const bfs = (arr, _targetId) => {
    const item = arr.find((item) => item.id === _targetId);
    if (item) {
      result = result ? `${result}/${item.text}` : item.text;
      if (_targetId !== targetId) {
        bfs(item.children, _targetId + "-" + ids[++index]);
      }
    } else {
      result = "没找到";
    }
  };

  bfs(treeNodes, ids[index]);

  return result;
}
```

### 再来一个笨方法

```js
function getBreadcrumbs(treeNodes, targetId) {
  let obj = {};
  let result = [];
  const findFather = (treeNodes, targetId) => {
    const _treeNodes = JSON.parse(JSON.stringify(treeNodes));
    _treeNodes.forEach((item) => {
      obj[item.id] = item;
      if (item.children) {
        item.children.forEach((child) => {
          // 标记父节点
          child.parentId = item.id;
        });
        findFather(item.children);
      }
    });
    return obj;
  };
  findFather(treeNodes, targetId);
  let head = targetId;
  while (obj[head] && obj[head].parentId) {
    result.push(obj[head].text);
    head = obj[head].parentId;
  }
  result.push(obj[head].text);
  return result.reverse().join("/");
}
```

### 深度优先遍历

上面的取巧方法优化吧

```js
function getBreadcrumbs(treeNodes, targetId) {
  let res = "";
  const bfs = (arr, result) => {
    if (!arr) return false;
    arr.forEach((item) => {
      const _result = result ? `${result}/${item.text}` : item.text;
      if (item.id === targetId) {
        res = _result;
      } else {
        bfs(item.children, _result);
      }
    });
  };
  bfs(treeNodes, "");
  return res;
}
```
